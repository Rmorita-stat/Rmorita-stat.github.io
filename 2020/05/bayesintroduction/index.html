<!DOCTYPE html>
<html>
<head>
    <meta name="google-site-verification" content="qrt5G5NouQQVS-0Ss9qHlEuMYt3uKuifbUIOkPd4cPc" />
    <meta charset="utf-8">
    <title>
        
        SUCRE HECACHA
        
    </title>
    <meta name="viewport" id="viewport" content="width=device-width, initial-scale=1">
    <link rel='icon' type='image/x-icon' href="https://sucre-stat.com/images/favicon.png" />
    <link rel="apple-touch-icon" href="https://sucre-stat.com/images/favicon.png"><link rel="stylesheet" href="https://sucre-stat.com/scss/style.css">
    
    <link rel="stylesheet" href="https://sucre-stat.com/css/syntax.css">
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
    <script src="https://sucre-stat.com/js/highlight.min.js"></script>
    <link rel="stylesheet" href="https://sucre-stat.com/scss/highlight.css">
    
    <link rel="stylesheet" href="https://sucre-stat.com/scss/custom.css">
    
    
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'Your Google Analytics tracking id', 'auto');
        ga('send', 'pageview');
    </script>
    
    
    <meta name="generator" content="Hugo 0.71.0" /><link href="https://use.fontawesome.com/releases/v5.6.1/css/all.css" rel="stylesheet">
</head>


<body>
<div class="header">
    <div class="site-logo__wrap">
        <div id="site-button">
            <div></div>
        </div>
        
        <div class=' site-logo '>
            <a href="https://sucre-stat.com/"><img src="https://sucre-stat.com/images/logo.png" /></a>
        </div>
    </div>
    
<div class=' site-nav u-font ' id="nav-bar">
    
    <div class="site-nav__wrap">
        <a class="site-nav__el" href="https://sucre-stat.com/stat" >STAT</a>
    </div>
    
    <div class="site-nav__wrap">
        <a class="site-nav__el" href="https://sucre-stat.com/r" >With R</a>
    </div>
    
    <div class="site-nav__wrap">
        <a class="site-nav__el" href="https://sucre-stat.com/julia" >With Julia</a>
    </div>
    
    <div class="site-nav__wrap">
        <a class="site-nav__el" href="https://sucre-stat.com/about" >ABOUT</a>
    </div>
    
    <div class="site-nav__wrap">
        <a class="site-nav__el" href="https://sucre-stat.com/tags/" >TAGS</a>
    </div>
    
<div class="site-nav__wrap">
<a class="site-nav__el current-page" href="https://sucre-stat.com/search/" ><i class="fas fa-search my_small"></i>SEARCH</a>
</div>
<div class="site-nav__wrap">
<a class="site-nav__el current-page" href="https://sucre-stat.com/contact/" >CONTACT</a>
</div>

</div>
<div class="main">

<div class="main-content">
    <div class="main-content__date">
        <h4 id="date"> 2020.05.29 23:50 </h4>
    </div>
    <div class="main-content__title">
        <h1 id="title">ベイズ統計モデリング入門</h1>
    </div>
    <div class="main-content__article">
        <article id="content">
            <h1 id="はじめに">はじめに</h1>
<p>本記事では今後の記事でも頻繁に扱う予定の<strong>ベイズ統計</strong>について理解してもらうため、その理論を簡単に説明します。</p>
<p>本記事の構成は以下の通りです。</p>
<!-- raw HTML omitted -->
<ul>
<li><a href="#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB">はじめに</a></li>
<li><a href="#%E3%83%8D%E3%82%A4%E3%83%9E%E3%83%B3%E3%83%BB%E3%83%94%E3%82%A2%E3%82%BD%E3%83%B3%E5%9E%8B%E7%B5%B1%E8%A8%88%E3%81%A8%E3%83%99%E3%82%A4%E3%82%BA%E7%B5%B1%E8%A8%88">ネイマン・ピアソン型統計とベイズ統計</a>
<ul>
<li><a href="#%E3%83%8D%E3%82%A4%E3%83%9E%E3%83%B3%E3%83%BB%E3%83%94%E3%82%A2%E3%82%BD%E3%83%B3%E5%9E%8B%E7%B5%B1%E8%A8%88">ネイマン・ピアソン型統計</a></li>
<li><a href="#%E3%83%99%E3%82%A4%E3%82%BA%E7%B5%B1%E8%A8%88">ベイズ統計</a></li>
<li><a href="#%E3%83%8D%E3%82%A4%E3%83%9E%E3%83%B3%E3%83%BB%E3%83%94%E3%82%A2%E3%82%BD%E3%83%B3%E5%9E%8B%E7%B5%B1%E8%A8%88%E3%81%A8%E3%83%99%E3%82%A4%E3%82%BA%E7%B5%B1%E8%A8%88%E3%81%AE%E6%95%B4%E5%90%88%E6%80%A7">ネイマン・ピアソン型統計とベイズ統計の整合性</a></li>
<li><a href="#%E3%83%8D%E3%82%A4%E3%83%9E%E3%83%B3%E3%83%BB%E3%83%94%E3%82%A2%E3%82%BD%E3%83%B3%E5%9E%8B%E7%B5%B1%E8%A8%88%E3%81%A8%E3%83%99%E3%82%A4%E3%82%BA%E7%B5%B1%E8%A8%88%E3%81%AE%E9%81%95%E3%81%84">ネイマン・ピアソン型統計とベイズ統計の違い</a></li>
</ul>
</li>
<li><a href="#%E3%83%9E%E3%83%AB%E3%82%B3%E3%83%95%E9%80%A3%E9%8E%96%E3%83%A2%E3%83%B3%E3%83%86%E3%82%AB%E3%83%AB%E3%83%AD%E6%B3%95mcmc">マルコフ連鎖モンテカルロ法(MCMC)</a></li>
<li><a href="#stan%E3%82%92%E7%94%A8%E3%81%84%E3%81%9Fmcmc%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AA%E3%83%B3%E3%82%B0">Stanを用いたMCMCサンプリング</a></li>
<li><a href="#%E3%81%BE%E3%81%A8%E3%82%81">まとめ</a></li>
</ul>
<!-- raw HTML omitted -->
<h1 id="ネイマンピアソン型統計とベイズ統計">ネイマン・ピアソン型統計とベイズ統計</h1>
<p>統計学の流派は大きく<strong>ネイマン・ピアソン型統計</strong>と<strong>ベイズ統計</strong>の2つが存在します。</p>
<h2 id="ネイマンピアソン型統計">ネイマン・ピアソン型統計</h2>
<p>ネイマン・ピアソン型統計では、母集団のパラメータ$\theta$(母平均や母分散など)を未知ではあるが固定された値であると考え、母集団からの標本$x$を確率的な変動をもって実現した値であるととらえます。
<!-- raw HTML omitted -->  <br>
そして、$\theta$を固定したとき、観察されたデータ$x$がどの程度生じやすいかの指標として、尤度
$$
P(x | \theta)
$$
を計算し、尤度が最も大きくなる値$\theta$を求めることで$\theta$の最尤推定量とする手法が、<strong>最尤法</strong>と呼ばれる、ネイマン・ピアソン型統計において最も重要な手法になります。</p>
<p>最尤推定に限らず、平均値の差の検定のような問題あっても、A群とB群の平均値に差がない($\mu_A = \mu_B$)という帰無仮説を設定することから始まり、設定した仮説のもとで、観察されたデータがどの程度の確率で起こるかをP値として求め、帰無仮説の真偽を判定します。</p>
<h2 id="ベイズ統計">ベイズ統計</h2>
<p>ベイズ統計では、ネイマン・ピアソン型統計とは対照的に、データ$x$を確定的な実現値であると考え、母集団のパラメータ$\theta$の方を確率的な分布を持った値であるとみなします。そのため、最終的に求めようとする対象は
$$
P(\theta|x)
$$
となります。</p>
<p>この$P(\theta|x)$ですが、ネイマン・ピアソン型統計の$P(x|\theta)$とは扱いが少し異なります。ベイズ統計における$P(\theta|x)$では「〇〇という条件のもと△△が得られる確率」における「〇〇」に対応する$x$が観測値として与えられています。また$P(\theta|x)$は$\theta$について積分すると1になります。このことから、$P(\theta|x)$は$x$が与えられると決定される$\theta$の<a href="https://bellcurve.jp/statistics/course/6602.html"><strong>確率密度関数</strong></a>もしくは<a href="https://bellcurve.jp/statistics/course/6598.html"><strong>確率質量関数</strong></a>ととらえることが出来ます。</p>
<p>一方、最尤推定における$P(x|\theta)$については、「〇〇という条件のもと△△が得られる確率」における「△△」に対応する$x$が観測値として与えられています。よって、$\theta$を1つの値に固定したとき、その値に応じて$x$の確率分布が変化することになりますが、$x$は観測値として与えられている為その分布自体が関心の対象となることはありません。より正確には、固定した$\theta$に応じて変わる$x$の確率密度関数・確率質量関数の、観測値の点に対応する値のみが関心の対象となっているといえます。</p>
<p>このあたり、図示すると分かりやすいので、時間を見つけて更新したいです。</p>
<p>ベイズ統計では、ベイズの定理と呼ばれる下記式が$P(\theta | x)$の推定に使用されます。</p>
<p>$$
P(\theta | x) = \cfrac{P(x | \theta)P(\theta)}{P(x)}
$$</p>
<p>$P(\theta|x)$を$\theta$の事後分布、$P(\theta)$を$\theta$の事前分布と呼びます。$P(x | \theta)$はネイマン・ピアソン型統計で紹介した尤度で、$\theta$を特定の値としたときに実現値$x$が得られる確率を意味します。</p>
<p>右辺の分子$P(x)$はデータ$x$が得られる確率ですが、これは$\theta$には依存しない、かつ未知の値であるため、$P(\theta | x)$の正規化定数ととらえ、下記式に基づいて$P(\theta | x)$を計算します。</p>
<p>$$
P(\theta | x) \propto P(x | \theta)P(\theta) = (尤度) × (事前分布)
$$</p>
<h2 id="ネイマンピアソン型統計とベイズ統計の整合性">ネイマン・ピアソン型統計とベイズ統計の整合性</h2>
<p>以上がネイマン・ピアソン型統計とベイズ統計の理論上の違いになりますが、ここで両者のアプローチの整合性について触れておきます。</p>
<p>事後分布$P(\theta|x)$の値が最大になる点$\hat{\theta}$は<strong>MAP推定値</strong>(maximum a posteriori estimate)と呼ばれますが、この値は$\theta$の事前分布$P(\theta)$を十分に分散が大きい正規分布や十分に幅の広い一様分布に設定することで無情報事前分布を指定すると、</p>
<p>$$
\newcommand{\argmax}{\mathop{\rm arg~max}\limits}
\hat{\theta} = \argmax_{\theta}~P(x|\theta)P(\theta) \ =  \argmax_{\theta}~ P(x|\theta)
$$</p>
<p>が成り立ちます。このことから、$\hat{\theta}$は最尤推定値と一致することがわかります。</p>
<h2 id="ネイマンピアソン型統計とベイズ統計の違い">ネイマン・ピアソン型統計とベイズ統計の違い</h2>
<p>ネイマン・ピアソン型統計とベイズ統計の分析上の違いをまとめておきます。</p>
<p><strong>パラメータの解釈</strong></p>
<p>ネイマン・ピアソン型統計ではパラメータは定数とみなします。<a href="http://localhost:1313/2020/05/multinom/">前回の記事</a>でも、モデルの係数は<code>summary(test)</code>で<code>Coefficients:</code>に確定値、<code>Std.Errors</code>に標準誤差が得られていました。この結果の解釈の仕方は、</p>
<p>「与えられたデータから推測される係数の値は(確定値)だ。ただし、同じ母集団から同じようにデータを取り直した場合、パラメータは(標準誤差)の分散をもって取得される」</p>
<p>となります。
<!-- raw HTML omitted --> <br>
一方、ベイズ統計では母集団のパラメータの分布が得られることから、</p>
<p>「パラメータがこの範囲である確率は何%だ」</p>
<p>もしくはより直接的に</p>
<p>「パラメータの確率密度関数の近似はこれだ」</p>
<p>といった解釈ができます。</p>
<p>この両者を比較すると、どちらが解釈しやすいでしょうか?
<!-- raw HTML omitted --><br>
人間の直感で理解しやすいのは後者の場合ではないかと思います。そのため、意思決定のために統計学的な分析を行うとき、ベイズ統計を選ぶことには利点があると考えられます。</p>
<p><strong>有意差問題</strong></p>
<p>ネイマン・ピアソン型統計では平均値の差の検定の際などに有意確率P値に着目し、P値が$\alpha$よりも小さければ帰無仮説を棄却、そうでなければ対立仮設を採択、といった判断を行います。</p>
<p>実はこの有意差検定、困ったことに、標本サイズを増やせばどんなに小さな平均値間の差であっても有意な差として検出できてしまうという問題があります。</p>
<p>これに対し、ベイズ統計からのアプローチでは、平均値の差という母集団のパラメータの確率分布を推定し、明示することができるため、ビックデータを扱う際にも、微小な平均値の差異は本当に有意なのか？といった問題から脱却することができます。</p>
<p>ベイズ推定では、標本数を増やすと求めたい分布は幅が狭くなっていく(より確信を持った分布を掲示できる)ため、ネイマン・ピアソン型統計よりもビックデータを有効活用できると考えられます。</p>
<p><strong>手法(最尤法とMCMC)による違い</strong></p>
<p>ネイマン・ピアソン型統計では最尤法が頻繫に使用されますが、この手法は過学習に陥りやすいという問題があります。また、モデルが複雑な場合、最尤法では局所最適地に陥りやすく、最適化が困難になります。</p>
<p>一方、ベイズ統計では次節で説明するMCMCを利用してパラメータの分布を求めるため、上記の問題が解決できます。</p>
<h1 id="マルコフ連鎖モンテカルロ法mcmc">マルコフ連鎖モンテカルロ法(MCMC)</h1>
<p>ベイズ統計では、パラメータの事後分布を求めることが目標となりますが、これを解析的に求めることは難しく、不可能であることも多いです。そのため、<strong>マルコフ連鎖モンテカルロ法</strong>(Malcov Chain Monte Carlo method、以下<strong>MCMC</strong>)というアルゴリズムを用います。
MCMCは、簡単に説明するとある確率分布に従う乱数を発生させるアルゴリズムです。これまでメトロポリス法、ギブスサンプラー、ハミルトニアンモンテカルロ法等様々なアルゴリズムが提案されていますが、ここではメトロポリス法を紹介し、MCMCがどのようなアルゴリズムなのか簡単に説明します。</p>
<p>以下のモデルを考えます。</p>
<p>$$
Y[n] \sim \rm{Normal}(\mu, 1)~~~~n=1,\ldots,N
$$
$$
\mu \sim \rm{Normal}(0, 100)
$$</p>
<p>ここで、$Y$:従属変数の観測値、$X$:説明変数の観測値、$N$：サンプルサイズです。
<!-- raw HTML omitted --><br>
事後確率$P(\mu|Y)$は下記式で計算できます。</p>
<p>$$
P(\mu | Y) \propto P(Y | \mu)P(\mu) =\left[ \prod_{n=0}^{N} \rm{Normal}(Y[n] | \mu, 1)\right] \rm{Normal}(\mu|0,100)
$$</p>
<p>このモデルにメトロポリス法を適用した場合、以下のようなアルゴリズムになります。</p>
<p><strong>[メトロポリス法]</strong>
<!-- raw HTML omitted --><br>
$\mu$を任意の初期状態からはじめて、以下を繰り返す。</p>
<ol>
<li>$\Delta$を原点対象の確率密度から発生させる。</li>
<li>サンプル候補の$\mu^{'}$を以下で定める。
$$
\mu^{'} \leftarrow \mu + \Delta
$$</li>
<li>サンプル候補と現在で$P(\mu|Y)$の比$r$を計算する。
$$
r \leftarrow \cfrac{\left[ \prod_{n=0}^{N} \rm{Normal}(Y[n] | \mu{'}, 1)\right] × \rm{Normal}(\mu{'}|0,100)}{\left[ \prod_{n=0}^{N} \rm{Normal}(Y[n] | \mu, 1)\right] × \rm{Normal}(\mu|0,100)}
$$</li>
<li>$0 \leq R &lt; 1$の一郎乱数$R$を発生させる。$R&lt;r$なら
$$
\mu \leftarrow \mu^{'}
$$
とし、そうでなければ現在の状態をそのまま次の状態とし、$\mu$を一つのmcmcサンプルとして保存する</li>
</ol>
<p>最後の操作において、$r \geqq 1$
のとき、$\mu^{'}$は必ず採択されることになります。一方、$r &lt; 1$のときでも確率$r$で$\mu^{'}$が採択されるところが重要で、この設定により$\mu^{'}$の局所的極大値に落ち着くことがなく、永遠にさまよい続けることになります。それでも、広い目で見ると$\mu^{'}$は(尤度)×(事前分布)が最大になる値付近に近づき、その周辺でサンプリングし続けることになります。</p>
<p>最後に、予測対象である$P(\mu | Y)$は、収集したMCMCサンプルの分布で近似されることになります。</p>
<h1 id="stanを用いたmcmcサンプリング">Stanを用いたMCMCサンプリング</h1>
<p>Stanは、ベイズモデリングを行うために開発された汎用的な確率的プログラミング言語です。推定計算のアルゴリズムにはハミルトニアンモンテカルロ法の一実装であるNUTSが用いられます。</p>
<p>MCMCによるサンプリングの様相を把握するため、例としてあるデータに対し下記のモデル
$$
Y[n] \sim \mathrm{Normal}(a + bX[n], \sigma)~~~~n=1,\ldots,N
$$
を適用し、確率的プログラミング言語<strong>Stan</strong>を用いてベイズ統計・MCMCを実行したときのtraceplot(MCMCサンプルの値をとった折れ線グラフ)と、MCMCサンプルの分布を以下に示します。</p>
<p><img src="https://sucre-stat.com/stat/bayesintroduction/p_a.png" alt="">
<img src="https://sucre-stat.com/stat/bayesintroduction/p_b.png" alt="">
<img src="https://sucre-stat.com/stat/bayesintroduction/p_sigma.png" alt=""></p>
<p>まずは左側のtraceplotを確認します。
<!-- raw HTML omitted -->  <br>
パラメータ毎に4つの折れ線がありますが、MCMCではサンプル列をいくつか並列で実行し、事後分布への収束を確認します。この1つのサンプル列を<strong>chain</strong>と呼び、ここではchain数が4となっています。</p>
<p>またtraceplotの左端を注意深く観察すると、サンプリングの初期ではあさっての値がサンプリングされていることがわかります。これはランダムに設定された初期値の影響を受けている為です。
そのためサンプリング初期の値は一般にサンプルから除外されます。この期間を<strong>warm up</strong>と呼び、warm up後のMCMCサンプルが事後分布からサンプリングされたものであると考えます。
<!-- raw HTML omitted -->上のtraceplotでは設定したwarm up期間を背景を濃くすることで表現しています。</p>
<p>traceplotを見る限り、warm up後のMCMCサンプルは初期値の影響を受けていないことから、正しいwarm up期間を設定できていると分かります。またこれ以上iterationを増やしても事後分布の形状に違いは生まれないように思われます。</p>
<p>次に右側のMCMCサンプルの分布を確認します。
<!-- raw HTML omitted -->  <br>
図では4つの確率密度分布が描画されており、これらは各chain毎にwarm upを除いたMCMCサンプルから作成した確率密度分布です。4つの密度分布は微妙な差がありますが、ほぼ同じ分布であることが分かります。</p>
<p><strong>ベイズ統計において求める対象は、パラメータに関する分布であり、実際の分析においては全chainのMCMCサンプルを混合し、一つの分布として扱う</strong>ことになります。</p>
<p>今回紹介した事例では、4つのchainがほぼ同じ部分をサンプリングし続けていること、chain毎のMCMCサンプルの分布がほぼ同じであることから、このMCMCは不変分布である事後分布に<strong>収束</strong>したと考えることが出来ます。
<!-- raw HTML omitted --> <br>
モデルや設定によっては上のtraceplotのようにならず、各chainが一つの値に収束しない場合もあります。そのような場合はモデルを再考したりする必要があります。</p>
<h1 id="まとめ">まとめ</h1>
<p>本記事ではベイズ統計について、ネイマン・ピアソン型統計と比較しつつ説明をしました。
どうしても文章ばかりの記事になってしまい、「結局何をしているの？」となってしまったかもしれません。
<!-- raw HTML omitted --><br>
次回の記事では実際にデータを用いてベイズ統計による分析を実施し、ネイマン・ピアソン型統計からのアプローチとの違いを確認したいと思います。</p>

        </article>
    </div>
    <div class="main-content__tags u-font">
        
        
        <span><a href="https://sucre-stat.com/tags/rstan">rstan</a></span>
        
        
    </div>

<div class="contact_form">
    <p>コメントを書く</p>
<form id="my-form" action="https://sucre-stat.com/" name="sampleCommentForm" method="post" netlify-honeypot="bot-field" netlify>
    <label>お名前：<input type="text" name="name" /></label>
    <label>Email(任意)： <input type="email" name="email" /></label>
    <label>コメント： <textarea name="content"></textarea></label>
  <p style="display:none;">
    <label>Bot Field(ここに値が入るとスパム判定する): <input name="bot-field"/></label>
  </p>
  <div>
    <button type="submit" value="Send">送信</button>
    <p><br>※ コメントは承認されると表示されます<br></p>
    <input type="hidden" name="path" value="/2020/05/bayesintroduction/index.html" />
    <p>承認されたコメント一覧</p>
    <ul class="comment" id="approvalCommentsList"></ul>

  </div>
</form>
</div>
<div class="main-profile">
    <div class="main-profile__avatar">
        
            <img src="https://sucre-stat.com/images/avatar.JPG">
        
    </div>
    <div class="main-profile__body">
        <div class="main-profile__author">
            
            <span> R.morita </span>
            
        </div>
        <div class="main-profile__description">
            
            <p> 得意なのは統一された洋服とダンスのステップです </p>
            
        </div>
    </div>
</div>
<div class="main-line"></div>
<div class="main-pn">
    
    
    <a class="next" href="https://sucre-stat.com/2020/07/gaussianprocess2/">
        <div class="pn-dec"></div>
        <div class="pn-els">
            <div class="pn-el__1"> 2020.07.11 00:00 </div>
            <div class="pn-el__2"> ガウス過程の応用 </div>
        </div>
    </a>
    
</div>

<footer>
  <script type="text/javascript">
 MathJax = {
   tex: {
     inlineMath: [['$','$'], ['\\(','\\)']],
     processEscapes: true,
     tags: "ams",
     autoload: {
       color: [],
       colorV2: ['color']
     },
     packages: {'[+]': ['noerrors']}
   },
   chtml: {
     matchFontHeight: true,
     displayAlign: "left",
     displayIndent: "2em"
   },
   options: {
     skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
     renderActions: {
        
       find_script_mathtex: [10, function (doc) {
         for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
           const display = !!node.type.match(/; *mode=display/);
           const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
           const text = document.createTextNode('');
           node.parentNode.replaceChild(text, node);
           math.start = {node: text, delim: '', n: 0};
           math.end = {node: text, delim: '', n: 0};
           doc.math.push(math);
         }
       }, '']
     }
   },
   loader: {
     load: ['[tex]/noerrors']
   }
 };
</script>
<script type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" id="MathJax-script"></script>
</footer>

</div>
<div class="footer">
    <div class="copyright-wrap">
        <p class="copyright u-font">
            
            &#169;
            2021
            
            <a href="https://github.com/Rmorita-stat/doc" target="_blank">R.morita&#46;</a>
            Theme <a href="https://github.com/iCyris/hugo-theme-yuki" target="_blank">yuki</a>&#46;
            Powered by Hugo&#46;
            
            
        </p>
    </div>
</div>
</body>
<script src="https://sucre-stat.com/js/page.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



<script src="//cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script language="javascript" type="text/javascript">

const url = '/comment/_data/sampleApprovedComments_submissions.json'
$.getJSON(url, (json) => {
  for (let i = 0; i < json.length; i++) {
    if (json[i].data.path !== '\/2020\/05\/bayesintroduction\/index.html') {
      continue
    }
    $('#approvalCommentsList').append(`<li>お名前　： ${json[i].data.name}<br>コメント： ${json[i].data.content}</li>`)
  }
})

// 送信前に一言感謝
$("#my-form").submit(function(e) {
  alert("Thank you!");
});
</script>
</body>
</html>
