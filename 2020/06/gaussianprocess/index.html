<!DOCTYPE html>
<html>
<head>
    <meta name="google-site-verification" content="qrt5G5NouQQVS-0Ss9qHlEuMYt3uKuifbUIOkPd4cPc" />
    <meta charset="utf-8">
    <title>
        
        SUCRE HECACHA
        
    </title>
    <meta name="viewport" id="viewport" content="width=device-width, initial-scale=1">
    <link rel='icon' type='image/x-icon' href="https://sucre-stat.com/images/favicon.png" />
    <link rel="apple-touch-icon" href="https://sucre-stat.com/images/favicon.png"><link rel="stylesheet" href="https://sucre-stat.com/scss/style.css">
    
    <link rel="stylesheet" href="https://sucre-stat.com/css/syntax.css">
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
    <script src="https://sucre-stat.com/js/highlight.min.js"></script>
    <link rel="stylesheet" href="https://sucre-stat.com/scss/highlight.css">
    
    <link rel="stylesheet" href="https://sucre-stat.com/scss/custom.css">
    
    
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'Your Google Analytics tracking id', 'auto');
        ga('send', 'pageview');
    </script>
    
    
    <meta name="generator" content="Hugo 0.71.0" /><link href="https://use.fontawesome.com/releases/v5.6.1/css/all.css" rel="stylesheet">
</head>


<body>
<div class="header">
    <div class="site-logo__wrap">
        <div id="site-button">
            <div></div>
        </div>
        
        <div class=' site-logo '>
            <a href="https://sucre-stat.com/"><img src="https://sucre-stat.com/images/logo.png" /></a>
        </div>
    </div>
    
<div class=' site-nav u-font ' id="nav-bar">
    
    <div class="site-nav__wrap">
        <a class="site-nav__el" href="https://sucre-stat.com/stat" >STAT</a>
    </div>
    
    <div class="site-nav__wrap">
        <a class="site-nav__el" href="https://sucre-stat.com/r" >With R</a>
    </div>
    
    <div class="site-nav__wrap">
        <a class="site-nav__el" href="https://sucre-stat.com/julia" >With Julia</a>
    </div>
    
    <div class="site-nav__wrap">
        <a class="site-nav__el" href="https://sucre-stat.com/about" >ABOUT</a>
    </div>
    
    <div class="site-nav__wrap">
        <a class="site-nav__el" href="https://sucre-stat.com/tags/" >TAGS</a>
    </div>
    
<div class="site-nav__wrap">
<a class="site-nav__el current-page" href="https://sucre-stat.com/search/" ><i class="fas fa-search my_small"></i>SEARCH</a>
</div>
<div class="site-nav__wrap">
<a class="site-nav__el current-page" href="https://sucre-stat.com/contact/" >CONTACT</a>
</div>

</div>
<div class="main">

<div class="main-content">
    <div class="main-content__date">
        <h4 id="date"> 2020.06.14 00:00 </h4>
    </div>
    <div class="main-content__title">
        <h1 id="title">ガウス過程入門</h1>
    </div>
    <div class="main-content__article">
        <article id="content">
            <h1 id="はじめに">はじめに</h1>
<p>今までに幾度かテーマにしていますが、回帰とよばれる問題があります。</p>
<p>例えば、車の速度とブレーキをかけてから車が止まるまでの距離について、データから両者の関係を把握したい、というような場合。最も単純な関係式でこの目的を果たそうとする場合、一般には以下に示す単回帰が用いられるでしょう。</p>
<p>$$
\mu_n = ax_n + b
$$
$$
y_n \sim \rm{Normal}(\mu_n, \sigma)
$$
$$
n=1, \ldots, N
$$</p>
<p>$Y$は目的変数(説明変数によって説明される変数)、$X$は説明変数(目的変数を説明する変数)、それぞれ$Y=(y_1, \ldots, y_n, \ldots, y_N)$、$X=(x_1, \ldots, x_n, \ldots, x_N)$です。
<img src="https://sucre-stat.com/r/gaussianprocess/plot1.png" alt="aai"></p>
<p>こんな需要もあるかもしれません。
上のモデルより少し難しいモデルですが、$X$、$Y$ともに非負の実数であることから、$Y$がガンマ分布に従うとし、リンク関数を$log$とした場合。
$$
\mu_n = \rm{exp}(ax_n + b)
$$
$$
y_n \sim \rm{Gamma}(\mu_n, \alpha, \beta)
$$</p>
<p><img src="https://sucre-stat.com/r/gaussianprocess/plot2.png" alt="aai"></p>
<p>上記の内容について理解が追い付かない場合は、<a href="https://cpp-learning.com/glm/">こちらのサイト</a>などを覗いてみてください。分かりやすくまとめられています。</p>
<p>分析の目的が変数間の関係把握であるならば、上述のモデルで事足りる場合も多いと思います。しかし「将来得られる可能性のある任意の値$X_{new}$に対応する$Y_{new}$の値を予測したい」というような場合、話は変わってきます。</p>
<p>これまでに得られたデータ$X$、$Y$の組から将来得られるデータ$X_{new}$に対応する$Y_{new}$の値を予測するとなると、より観測データにフィットできる柔軟なモデルを構築することが理想です(ただし過学習には要注意)。</p>
<p>今回は、上記のような期待に応えるモデルとして<strong>ガウス過程</strong>を取り上げ、
データに対し柔軟な回帰曲線を得られるようにすることを最終目標とします。</p>
<p>参考図書は<a href="https://www.kspub.co.jp/book/detail/1529267.html">こちら</a>です。
<a href="https://matsueushi.github.io/posts/gp-parameter-estimation/">こちらのブログ</a>も大いに参考にさせていただきました。RもいいですがJuliaも面白そうです。影響を受けてJuliaの参考書を買ってしまいました。</p>
<p>本記事の構成は以下の通りです。</p>
<!-- raw HTML omitted -->
<ul>
<li><a href="#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB">はじめに</a></li>
<li><a href="#%E3%82%AC%E3%82%A6%E3%82%B9%E9%81%8E%E7%A8%8B%E3%81%AE%E5%AE%9A%E7%BE%A9">ガウス過程の定義</a>
<ul>
<li><a href="#%E3%82%AC%E3%82%A6%E3%82%B9%E9%81%8E%E7%A8%8B%E3%81%AE%E5%B0%8E%E5%87%BA">ガウス過程の導出</a></li>
<li><a href="#%E3%82%AC%E3%82%A6%E3%82%B9%E9%81%8E%E7%A8%8B%E3%81%AE%E7%9B%B4%E6%84%9F%E7%9A%84%E3%81%AA%E6%80%A7%E8%B3%AA">ガウス過程の直感的な性質</a></li>
<li><a href="#%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB%E9%96%A2%E6%95%B0">カーネル関数</a></li>
</ul>
</li>
<li><a href="#%E3%82%AC%E3%82%A6%E3%82%B9%E9%81%8E%E7%A8%8B%E3%81%AE%E3%82%B7%E3%83%9F%E3%83%A5%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3">ガウス過程のシミュレーション</a>
<ul>
<li><a href="#%E3%82%AC%E3%82%A6%E3%82%B9%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB%E3%81%AE%E3%82%B7%E3%83%9F%E3%83%A5%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3">ガウスカーネルのシミュレーション</a></li>
<li><a href="#%E7%B7%9A%E5%BD%A2%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB%E3%81%AE%E3%82%B7%E3%83%9F%E3%83%A5%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3">線形カーネルのシミュレーション</a></li>
<li><a href="#matern3%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB%E3%81%AE%E3%82%B7%E3%83%9F%E3%83%A5%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3">Matern3カーネルのシミュレーション</a></li>
<li><a href="#%E3%82%AC%E3%82%A6%E3%82%B9%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB%E3%81%A8%E7%B7%9A%E5%BD%A2%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB%E3%81%AE%E7%B5%90%E5%90%88">ガウスカーネルと線形カーネルの結合</a></li>
</ul>
</li>
<li><a href="#%E5%AE%9F%E9%9A%9B%E3%81%AB%E5%9B%9E%E5%B8%B0%E3%83%BB%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%E6%8E%A8%E5%AE%9A%E3%82%92%E5%AE%9F%E8%A1%8C">実際に回帰・パラメータ推定を実行</a>
<ul>
<li><a href="#%E3%82%AC%E3%82%A6%E3%82%B9%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%9F%E5%9B%9E%E5%B8%B0">ガウスカーネルを使った回帰</a></li>
<li><a href="#%E3%82%AC%E3%82%A6%E3%82%B9%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB%EF%BC%8B%E7%B7%9A%E5%BD%A2%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB%E3%81%A7%E5%9B%9E%E5%B8%B0">ガウスカーネル＋線形カーネルで回帰</a></li>
<li><a href="#%E6%83%85%E5%A0%B1%E9%87%8F%E5%9F%BA%E6%BA%96%E3%81%AE%E7%A2%BA%E8%AA%8D">情報量基準の確認</a></li>
</ul>
</li>
<li><a href="#%E3%81%BE%E3%81%A8%E3%82%81">まとめ</a></li>
</ul>
<!-- raw HTML omitted -->
<h1 id="ガウス過程の定義">ガウス過程の定義</h1>
<h2 id="ガウス過程の導出">ガウス過程の導出</h2>
<p>ガウス過程について特にわかりやすいと思った参考図書の記載を抜粋してガウス過程について説明します。</p>
<p>この節の理解には多変量正規分布($\rm{MultiNormal}()$)の理解が必要です。多変量正規分布については参考図書などを見て適宜補完してください。</p>
<p>以下の線形回帰モデルを考えます。</p>
<p>特徴ベクトルの要素数を$H$とします。
<!-- raw HTML omitted -->  <br>
特徴ベクトルとは機械学習分野の用語で、変換処理によって抽出されるデータの特徴を要素に持つベクトルです。
<!-- raw HTML omitted -->  <br>
$\phi(x)$は説明変数群$X$(機械学習分野では入力と呼びます)の要素$x$に関する特徴ベクトルです。</p>
<p>$$
\phi(x) = (\phi_1(x), \phi_2(x), \phi_3(x), \ldots, \phi_H(x))
$$</p>
<p>$w$は各特徴の重みです。</p>
<p>$$
w = (w_1, w_2,w_3, \ldots, w_H)^T
$$</p>
<p>$\hat{y}$を目的変数$Y$の要素$y$についての予測値とすると、</p>
<p>$$
\hat{y} = \phi(x)w　\tag{1}
$$</p>
<p>とおけます。
<!-- raw HTML omitted -->  <br>
さらに式(1)を$(\hat{y}_1,x_1), \ldots, (\hat{y}_N,x_N)$についてまとめると、</p>
<p>$$
\left(
\begin{array}{ccc}
\hat{y}_1 \\<br>
\hat{y}_2 \\<br>
\vdots \\<br>
\hat{y}_N
\end{array}
\right) =
\left(
\begin{array}{ccc}
\phi_1(x_1) &amp; \phi_2(x_1) &amp; \cdots &amp; \phi_H(x_1) \\<br>
\phi_1(x_2) &amp; \phi_2(x_2) &amp; \cdots &amp; \phi_H(x_2) \\<br>
\cdots &amp; \cdots &amp; \ddots &amp; \cdots \\<br>
\phi_1(x_N) &amp; \phi_2(x_N) &amp; \cdots &amp; \phi_H(x_N)
\end{array}
\right)
\left(
\begin{array}{ccc}
w_1 \\<br>
w_2 \\<br>
\vdots \\<br>
w_H
\end{array}
\right) \tag{2}
$$</p>
<p>とおけます。
ここで$\phi_{nh} = \phi_{h}(x_n)$を要素に持つ計画行列(統計モデルの基底関数についての行列)$\Phi$を使うと、式(2)は</p>
<p>$$
\hat{Y} = \Phi w　\tag{3}
$$</p>
<p>とまとめられます。</p>
<p>式(3)を使えば、基底関数を自由に設定したり、基底関数の次元を増やすことでほとんど任意の形の関数が表現できそうです。しかし、$x$が高次元であるほど基底関数の数を多く設定する必要があり、そうなるとパラメータ$w$もどんどん増えていってしまい、最終的にはパラメータ$w$の推定が不可能なほどになってしまいそうです。</p>
<p>そこで、パラメータwの<strong>周辺化消去</strong>(期待値をとって積分消去)を考えます。</p>
<p>$w$が平均0、分散$\lambda^2I$の互いに独立な正規分布に従うと仮定し、重み$w$が特定の基底関数に偏り、過学習に陥りにくいように設定します。</p>
<p>$$
w \sim \rm{MultiNormal}(0, \lambda^2I) \tag{4}
$$</p>
<p>これによって$w$の期待値を仮定し、周辺化消去を行うのですが、その過程は省略し、結果のみを以下に書きます。</p>
<p>$$
Y \sim \rm{MultiNormal}(0, \lambda^2\Phi\Phi^T) \tag{5}
$$</p>
<p><strong>式(5)がガウス過程を定義する式</strong>です。これは式(3)と基本的に同じ機能をもつため、式(3)と同様、ほとんどどんな形でも表現できそうです。ただし、線形回帰モデル式(3)にあったパラメータ$w$が積分消去されているため、$x$の次元がいくら高くなっても推定するパラメータは増えず、$y$の分布はデータ数$N$に依存する共分散行列$\lambda^2\Phi\Phi^T$のみによって決定します。さらに式(3)からの変形で式(4)をかませているため、過学習に陥る可能性が抑えられています。</p>
<h2 id="ガウス過程の直感的な性質">ガウス過程の直感的な性質</h2>
<p>ガウス過程の性質を決定する共分散行列について見ていきます。</p>
<p>$$
K = \lambda^2\Phi\Phi^T
$$</p>
<p>とおくと、この$(n, n^{'})$要素は</p>
<p>$$
k_{nn^{'}} = \lambda^2\phi(x_n)^T\phi(x_{n^{'}})
$$</p>
<p>なので、これは$x_{n}$と$x_{n^{'}}$の特徴ベクトル$\phi(x_{n})$と$\phi(x_{n^{'}})$の内積の$\lambda^2$倍です。多変量正規分布において２変数の共分散が大きいとき、両者の相関が高いということなので、２変数の平均値が同値かつ共分散が大きいとき、両者は似た値をとりやすくなります。
<!-- raw HTML omitted -->  <br>
つまり、$x_{n}$と$x_{n^{'}}$が設定した特徴ベクトル空間において似ている場合、対応する$y_{n}$と$y_{n^{'}}$も似た値が出力されやすくなります。このように、説明変数$x$が似ていれば目的変数の予測値$y$も似た値となる、というのがガウス過程の性質になります。</p>
<h2 id="カーネル関数">カーネル関数</h2>
<p>$$
k_{nn^{'}} = \phi(x_n)^T\phi(x_{n^{'}})　\tag{6}
$$</p>
<p>これを特徴ベクトルから計算しようとすると、複雑な計算が要求されます。そうではなく、式(6)を計算するための関数として、<strong>カーネル関数</strong>を用います。また、カーネル関数を用いて内積を計算することを<strong>カーネルトリック</strong>と呼びます。</p>
<p>カーネル関数は、何らかの無限次元の特徴ベクトル空間における２点の内積を表現できる、という特徴をもつ関数で、それぞれに異なる無限次元特徴ベクトルを定義する様々なカーネル関数があります。</p>
<p>例えば、カーネル関数の１種、ガウスカーネル</p>
<p>$$
k(x,x_{'}) = \rm{exp}(-a(x-x^{'})^2)
$$</p>
<p>の場合、</p>
<p>$$
\rm{exp}(-a(x-x^{'}))^2 = \phi(x)^{T}\phi(x^{'})
$$</p>
<p>となる特徴ベクトルは、第$r$成分が</p>
<p>$$
\phi_r(x) = \left(\cfrac{4a}{\pi}\right)^{\cfrac{1}{4}}\rm{exp}(-2a(x-r)^2)
$$</p>
<p>となります($r$は実数で、$r=-\infty, \ldots, \infty$)。</p>
<p>これは、
$$
\int_{-\infty}^{\infty} \phi_r(x)\phi_r(x^{'}) dr = exp(-a(x-x^{'}))^2
$$</p>
<p>を証明することで確認できます。証明は<a href="https://mathwords.net/gausskernel">こちらのサイト</a>で見れます。</p>
<p>なお、通常のパラメータとは設定目的の異なる、モデルの複雑さを決定するパラメータはハイーパーパラメータ(超母数)などと呼ばれます。以降、カーネル関数のパラメータもハイパーパラメータと呼ぶことにします。</p>
<h1 id="ガウス過程のシミュレーション">ガウス過程のシミュレーション</h1>
<p>ガウス過程の概要を確認したので、ガウス過程に従う確率変数がどのような挙動をするのか、いくつかのカーネル関数を例に見てみます。</p>
<p>シミュレーションの前に、カーネル行列($K$のこと)を作成する関数と、シミュレーションのための関数を定義しておきます。</p>
<div class="highlight"><pre class="chroma"><code class="language-r" data-lang="r"><span class="c1"># カーネル行列を作成する関数を定義</span>
<span class="c1"># 引数 kernel：この後に定義するカーネル関数を指定 x：トレーニングデータ</span>
<span class="c1"># 引数 par:kernelが要求するハイパーパラメータ delta：誤差の要素。ハイパーパラメータとは別で指定することにした</span>
<span class="n">kernel_cov</span> <span class="o">&lt;-</span> <span class="nf">function</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="n">par</span><span class="p">,</span> <span class="n">delta</span><span class="p">){</span>
  <span class="n">NL</span> <span class="o">&lt;-</span> <span class="nf">length</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">Sigma</span> <span class="o">&lt;-</span> <span class="nf">matrix</span><span class="p">(</span><span class="kc">NA</span><span class="p">,</span> <span class="n">nrow</span><span class="o">=</span><span class="n">NL</span><span class="p">,</span> <span class="n">ncol</span><span class="o">=</span><span class="n">NL</span><span class="p">)</span>
  <span class="nf">for</span><span class="p">(</span><span class="n">i</span> <span class="n">in</span> <span class="m">1</span><span class="o">:</span><span class="p">(</span><span class="n">NL</span><span class="m">-1</span><span class="p">)){</span>
    <span class="n">Sigma[i</span><span class="p">,</span><span class="n">i]</span> <span class="o">&lt;-</span> <span class="nf">kernel</span><span class="p">(</span><span class="n">x[i]</span><span class="p">,</span><span class="n">x[i]</span><span class="p">,</span><span class="n">par</span><span class="p">)</span> <span class="o">+</span> <span class="n">delta</span>
    <span class="nf">for</span><span class="p">(</span><span class="n">j</span> <span class="nf">in </span><span class="p">(</span><span class="n">i</span><span class="m">+1</span><span class="p">)</span><span class="o">:</span><span class="n">NL</span><span class="p">){</span>
      <span class="n">Sigma[i</span><span class="p">,</span><span class="n">j]</span> <span class="o">&lt;-</span> <span class="nf">kernel</span><span class="p">(</span><span class="n">x[i]</span><span class="p">,</span><span class="n">x[j]</span><span class="p">,</span><span class="n">par</span><span class="p">)</span>
      <span class="n">Sigma[j</span><span class="p">,</span><span class="n">i]</span> <span class="o">&lt;-</span> <span class="n">Sigma[i</span><span class="p">,</span><span class="n">j]</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">Sigma[NL</span><span class="p">,</span><span class="n">NL]</span> <span class="o">&lt;-</span> <span class="nf">kernel</span><span class="p">(</span><span class="n">x[NL]</span><span class="p">,</span><span class="n">x[NL]</span><span class="p">,</span><span class="n">par</span><span class="p">)</span> <span class="o">+</span> <span class="n">delta</span>
  <span class="nf">return</span><span class="p">(</span><span class="n">Sigma</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1"># シミュレーションのための自作関数を定義</span>
<span class="n">GP_sim</span> <span class="o">&lt;-</span> <span class="nf">function</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">par</span><span class="p">){</span>
  <span class="n">p</span> <span class="o">&lt;-</span> <span class="nf">ggplot</span><span class="p">()</span> <span class="o">+</span> <span class="nf">theme_bw</span><span class="p">(</span><span class="n">base_size</span> <span class="o">=</span> <span class="m">11</span><span class="p">)</span>
  <span class="n">i</span> <span class="o">&lt;-</span> <span class="m">0</span>
  <span class="n">xs</span> <span class="o">=</span> <span class="nf">seq</span><span class="p">(</span><span class="m">-4</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">0.05</span><span class="p">)</span>
  <span class="n">repeat</span><span class="p">{</span>
    <span class="n">i</span> <span class="o">&lt;-</span> <span class="n">i</span> <span class="o">+</span> <span class="m">1</span>
    <span class="nf">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="m">5</span><span class="p">)</span> <span class="n">break</span>
    <span class="n">p</span> <span class="o">&lt;-</span> <span class="n">p</span> <span class="o">+</span> <span class="nf">geom_line</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="nf">data.frame</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">xs</span><span class="p">,</span>
                                       <span class="n">y</span> <span class="o">=</span> <span class="n">MASS</span><span class="o">::</span><span class="nf">mvrnorm</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="nf">rep</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="nf">length</span><span class="p">(</span><span class="n">xs</span><span class="p">)),</span>
                                                         <span class="nf">kernel_cov</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="n">xs</span><span class="p">,</span> <span class="n">par</span><span class="o">=</span><span class="n">par</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="m">1e-8</span><span class="p">))),</span>
                       <span class="nf">aes</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">),</span> <span class="n">colour</span><span class="o">=</span><span class="nf">as.factor</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
  <span class="p">}</span>
  <span class="nf">plot</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="ガウスカーネルのシミュレーション">ガウスカーネルのシミュレーション</h2>
<p>前の節で紹介したガウスカーネルのシミュレーションです。改めてガウスカーネルを再定義します。
<!-- raw HTML omitted -->  <br>
ガウスカーネルは、下のようにrateパラメータ$\theta$、shapeパラメータ$\rho$をもちます。ここでは$\theta$、$\rho$ともに１とした場合のシミュレーションをします。</p>
<p>$$
k(x,x_{'}) = \theta \rm{exp}\left(-\cfrac{(x-x^{'})^2}{\rho}\right)
$$</p>
<div class="highlight"><pre class="chroma"><code class="language-r" data-lang="r"><span class="c1">## ガウスカーネルの定義 kernel_cov()で使用できるように、引数は(x1,x2,par)でないといけない</span>
<span class="c1">## カーネルのハイパーパラメータはすべてparで指定する</span>
<span class="n">Gaussian_kernel</span> <span class="o">&lt;-</span> <span class="nf">function</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">par</span><span class="p">){</span>
  <span class="nf">return</span><span class="p">(</span><span class="n">par[1]</span><span class="o">*</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span><span class="n">^2</span><span class="o">/</span><span class="n">par[2]</span><span class="p">))</span>
<span class="p">}</span>

<span class="nf">GP_sim</span><span class="p">(</span><span class="n">Gaussian_kernel</span><span class="p">,</span> <span class="n">par</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">))</span>
</code></pre></div><p><img src="https://sucre-stat.com/r/gaussianprocess/sim_1.png" alt=""></p>
<p>ガウスカーネルをカーネル関数に設定したガウス過程は、無限回微分可能な滑らかな曲線になるそうです。</p>
<h2 id="線形カーネルのシミュレーション">線形カーネルのシミュレーション</h2>
<p>線形カーネルは、ハイパーパラメータを持たないカーネル関数です。</p>
<p>$$
k(x,x_{'}) = x^T x^{'}
$$</p>
<p>線形カーネルは、$\phi(x)=x$としているので、これを式(1)に代入すると、$x$の中に定数項$x_0=1$が含まれているとした場合、通常の重回帰と等価であることが分かります。</p>
<div class="highlight"><pre class="chroma"><code class="language-r" data-lang="r"><span class="c1">## 線形カーネルを定義。ハイパーパラメータは無し</span>
<span class="n">linear_kernel</span> <span class="o">&lt;-</span> <span class="nf">function</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">par</span><span class="p">){</span>
  <span class="nf">return</span><span class="p">(</span><span class="m">1</span> <span class="o">+</span> <span class="nf">t</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span><span class="o">%*%</span><span class="n">x2</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">GP_sim</span><span class="p">(</span><span class="n">linear_kernel</span><span class="p">,</span> <span class="n">par</span><span class="o">=</span><span class="kc">NULL</span><span class="p">)</span>
</code></pre></div><p><img src="https://sucre-stat.com/r/gaussianprocess/sim_2.png" alt=""></p>
<p>シミュレーションでも直線が引けることが確認できます。</p>
<h2 id="matern3カーネルのシミュレーション">Matern3カーネルのシミュレーション</h2>
<p>Maternカーネルは、ガウスカーネルの無限回微分可能という前提がモデル化において強すぎるという主張から提案されたカーネルです。</p>
<p>$$
k_v(x,x^{'}) = \cfrac{2^{1-\upsilon}}{\Gamma(\upsilon)} \left( \cfrac{\sqrt{2\upsilon}r}{\upsilon} \right)^2 K_v \left( \cfrac{\sqrt{2\upsilon}r}{\upsilon} \right) ~~~ (r=|x-x^{'}|)
$$</p>
<p>Maternカーネルを用いたガウス過程から生成される関数は、「$\upsilon$以下の最大の整数」回分微分可能で、$\upsilon$は$\cfrac{3}{2},\cfrac{5}{2} $などが使われ、それぞれMatern3、Matern5と呼ばれるようです。</p>
<p>Matern3カーネルは以下のようになります。</p>
<p>$$
k_{3/2}(x,x^{'}) = \left(1 + \cfrac{\sqrt{3}r}{\theta} \right) exp\left( -\cfrac{\sqrt{3}r}{\theta} \right)
$$</p>
<p>このMatern3カーネルを$\theta=1$としてシミュレーションしてみます。</p>
<div class="highlight"><pre class="chroma"><code class="language-r" data-lang="r"><span class="c1"># Matern3カーネルを定義</span>
<span class="n">Matern3_kernel</span> <span class="o">&lt;-</span> <span class="nf">function</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span> <span class="n">par</span><span class="p">){</span>
  <span class="nf">return</span><span class="p">((</span><span class="m">1</span> <span class="o">+</span> <span class="nf">sqrt</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="o">*</span><span class="nf">abs</span><span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x2</span><span class="p">)</span><span class="o">/</span><span class="n">par[1]</span><span class="p">)</span><span class="o">*</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="nf">sqrt</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="o">*</span><span class="nf">abs</span><span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x2</span><span class="p">)</span><span class="o">/</span><span class="n">par[2]</span><span class="p">))</span>
<span class="p">}</span>

<span class="nf">GP_sim</span><span class="p">(</span><span class="n">Matern3_kernel</span><span class="p">,</span><span class="n">par</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">))</span>
</code></pre></div><p><img src="https://sucre-stat.com/r/gaussianprocess/sim_3.png" alt=""></p>
<p>ガウスカーネルと比べていびつな曲線になっていることが分かります。</p>
<h2 id="ガウスカーネルと線形カーネルの結合">ガウスカーネルと線形カーネルの結合</h2>
<p>カーネル関数は組み合わせて使うことも可能です。
ここではガウスカーネルと線形カーネルを組み合わせてみます。</p>
<p>$$
k(x,x_{'}) = \theta_1 \rm{exp}\left(-\cfrac{(x-x^{'})^2}{\rho}\right) + \theta_2x^T x^{'}
$$</p>
<p>上の式において、$\theta_1=0.8, \theta_2=2, \rho=0.07$としたときのシミュレーションです。</p>
<div class="highlight"><pre class="chroma"><code class="language-r" data-lang="r"><span class="c1"># ガウスカーネル＋線形カーネルの定義</span>
<span class="n">Gaussian_plus_Linear_kernel</span> <span class="o">&lt;-</span> <span class="nf">function</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">par</span><span class="p">){</span>
  <span class="nf">return</span><span class="p">(</span><span class="n">par[1]</span> <span class="o">*</span> <span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span><span class="n">^2</span><span class="o">/</span><span class="n">par[2]</span><span class="p">)</span> <span class="o">+</span> <span class="n">par[3]</span> <span class="o">*</span> <span class="p">(</span><span class="m">1</span> <span class="o">+</span> <span class="nf">t</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span><span class="o">%*%</span><span class="n">x2</span><span class="p">))</span>
<span class="p">}</span>

<span class="nf">GP_sim</span><span class="p">(</span><span class="n">Gaussian_plus_Linear_kernel</span><span class="p">,</span><span class="nf">c</span><span class="p">(</span><span class="m">0.8</span><span class="p">,</span><span class="m">0.07</span><span class="p">,</span><span class="m">2</span><span class="p">))</span>
</code></pre></div><p><img src="https://sucre-stat.com/r/gaussianprocess/sim_4.png" alt=""></p>
<p>ガウスカーネルと線形カーネルがうまく組み合わさっていることが分かります。</p>
<h1 id="実際に回帰パラメータ推定を実行">実際に回帰・パラメータ推定を実行</h1>
<p>ひととおりシミュレーションしたので実践です。
まずは参考図書と同じ、陸上男子100mの世界記録のデータを準備します。$x$は世界記録更新日、$y$は世界記録のタイムです。</p>
<div class="highlight"><pre class="chroma"><code class="language-r" data-lang="r"><span class="c1"># データの準備</span>
<span class="n">x</span> <span class="o">&lt;-</span> <span class="nf">as.Date</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s">&#34;1964/10/15&#34;</span><span class="p">,</span><span class="s">&#34;1968/6/20&#34;</span><span class="p">,</span><span class="s">&#34;1968/10/13&#34;</span><span class="p">,</span><span class="s">&#34;1968/10/14&#34;</span><span class="p">,</span><span class="s">&#34;1983/7/3&#34;</span><span class="p">,</span><span class="s">&#34;1987/8/30&#34;</span><span class="p">,</span><span class="s">&#34;1988/8/17&#34;</span><span class="p">,</span>
                 <span class="s">&#34;1988/9/24&#34;</span><span class="p">,</span><span class="s">&#34;1991/7/14&#34;</span><span class="p">,</span><span class="s">&#34;1991/8/25&#34;</span><span class="p">,</span><span class="s">&#34;1994/7/6&#34;</span><span class="p">,</span><span class="s">&#34;1996/7/27&#34;</span><span class="p">,</span><span class="s">&#34;1999/6/16&#34;</span><span class="p">,</span><span class="s">&#34;2002/9/14&#34;</span><span class="p">,</span>
                 <span class="s">&#34;2005/6/14&#34;</span><span class="p">,</span><span class="s">&#34;2006/5/12&#34;</span><span class="p">,</span><span class="s">&#34;2006/6/11&#34;</span><span class="p">,</span><span class="s">&#34;2006/8/18&#34;</span><span class="p">,</span><span class="s">&#34;2007/9/9&#34;</span><span class="p">,</span><span class="s">&#34;2008/5/31&#34;</span><span class="p">,</span><span class="s">&#34;2008/8/16&#34;</span><span class="p">,</span><span class="s">&#34;2009/8/16&#34;</span><span class="p">))</span>
<span class="n">y</span> <span class="o">&lt;-</span> <span class="nf">c</span><span class="p">(</span><span class="m">10.06</span><span class="p">,</span><span class="m">10.03</span><span class="p">,</span><span class="m">10.02</span><span class="p">,</span><span class="m">9.95</span><span class="p">,</span><span class="m">9.93</span><span class="p">,</span><span class="m">9.93</span><span class="p">,</span><span class="m">9.93</span><span class="p">,</span><span class="m">9.92</span><span class="p">,</span><span class="m">9.9</span><span class="p">,</span><span class="m">9.86</span><span class="p">,</span><span class="m">9.85</span><span class="p">,</span><span class="m">9.84</span><span class="p">,</span><span class="m">9.79</span><span class="p">,</span><span class="m">9.78</span><span class="p">,</span><span class="m">9.77</span><span class="p">,</span><span class="m">9.77</span><span class="p">,</span><span class="m">9.77</span><span class="p">,</span><span class="m">9.77</span><span class="p">,</span><span class="m">9.74</span><span class="p">,</span><span class="m">9.72</span><span class="p">,</span><span class="m">9.69</span><span class="p">,</span><span class="m">9.58</span><span class="p">)</span>

<span class="c1"># 標準化</span>
<span class="n">x</span> <span class="o">&lt;-</span> <span class="p">(</span><span class="nf">as.numeric</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="nf">mean</span><span class="p">(</span><span class="nf">as.numeric</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span><span class="o">/</span><span class="nf">sd</span><span class="p">(</span><span class="nf">as.numeric</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="n">y</span> <span class="o">&lt;-</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="nf">mean</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">/</span><span class="nf">sd</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

<span class="nf">library</span><span class="p">(</span><span class="n">ggplot2</span><span class="p">)</span>
<span class="n">p</span> <span class="o">&lt;-</span> <span class="nf">ggplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="nf">data.frame</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">),</span> <span class="nf">aes</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">))</span> <span class="o">+</span> <span class="nf">theme_bw</span><span class="p">(</span><span class="n">base_size</span><span class="o">=</span><span class="m">11</span><span class="p">)</span> <span class="o">+</span> <span class="nf">geom_point</span><span class="p">()</span>
<span class="n">p</span>
</code></pre></div><p><img src="https://sucre-stat.com/r/gaussianprocess/data_plot.png" alt=""></p>
<p>分析にあたって、まずはハイパーパラメータの最適な値を推定します。
<!-- raw HTML omitted -->推定方法にはハイパーパラメータを少しずつ変えてその事後分布を推定するMCMCも使えますが、ここでは計算量の少ない効率的な方法として<strong>勾配法</strong>を用います。
簡略化のため、ガウス過程のハイパーパラメータを$\theta=(\theta_1, \theta_2,\ldots)$とまとめておき、カーネル行列も$K_{\theta}$とします。
確率変数$Y$がガウス過程$GP(0,K_\theta)$に従うと仮定したとき、観測値に対する尤度は、</p>
<p>$$
p(Y|X,\theta) = \rm{MultiNormal}(Y|o,K_{\theta}) =
\cfrac{1}{(2\pi)^{N/2}} \cfrac{1}{|K_{\theta}|^{1/2}} exp\left(\cfrac{1}{2}Y^TK_{\theta}^{-1}Y\right)
$$</p>
<p>対数尤度は、</p>
<p>$$
\log(Y|X,\theta)~~ = ~~ -\cfrac{N}{2}\log(2\pi)-\cfrac{1}{2}\log|K_{\theta}|-\cfrac{1}{2}Y^TK_{\theta}^{-1}Y~~
\propto~~ -\log|K_{\theta}|-Y^TK_{\theta}^{-1}Y +(定数) \tag{7}　
$$</p>
<p>です。
式(7)を最大にする$\theta$を求め、ハイパーパラメータの最適な値とします。
<!-- raw HTML omitted -->  <br>
式(7)を計算する自作関数を以下で定義します。</p>
<div class="highlight"><pre class="chroma"><code class="language-r" data-lang="r"><span class="c1"># ガウス過程モデルの対数尤度に比例する値を計算する関数を定義</span>

<span class="n">GP_L</span> <span class="o">&lt;-</span> <span class="nf">function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">par</span><span class="p">,</span> <span class="n">kernel</span><span class="p">){</span>
  <span class="nf">return</span><span class="p">(</span><span class="o">-</span><span class="nf">log</span><span class="p">(</span><span class="nf">det</span><span class="p">(</span><span class="nf">kernel_cov</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">par</span><span class="o">=</span><span class="nf">exp</span><span class="p">(</span><span class="n">par[</span><span class="o">-</span><span class="nf">length</span><span class="p">(</span><span class="n">par</span><span class="p">)</span><span class="n">]</span><span class="p">),</span><span class="n">delta</span><span class="o">=</span><span class="nf">exp</span><span class="p">(</span><span class="n">par</span><span class="nf">[length</span><span class="p">(</span><span class="n">par</span><span class="p">)</span><span class="n">]</span><span class="p">))))</span>
         <span class="o">-</span><span class="nf">t</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">%*%</span>
           <span class="nf">solve</span><span class="p">(</span><span class="nf">kernel_cov</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">par</span><span class="o">=</span><span class="nf">exp</span><span class="p">(</span><span class="n">par[</span><span class="o">-</span><span class="nf">length</span><span class="p">(</span><span class="n">par</span><span class="p">)</span><span class="n">]</span><span class="p">),</span> <span class="n">delta</span><span class="o">=</span><span class="nf">exp</span><span class="p">(</span><span class="n">par</span><span class="nf">[length</span><span class="p">(</span><span class="n">par</span><span class="p">)</span><span class="n">]</span><span class="p">)))</span><span class="o">%*%</span><span class="n">y</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>式(7)を最大にする$\theta$は、Rの汎用最適化関数の<code>optim()</code>を使います。参考図書では式(7)を$\theta$の各ハイパーパラメータで偏微分した式が紹介されています。<code>optim()</code>では引数<code>gr</code>で一階偏微分関数を指定でき、簡単に定義できるなら明示的に指定した方が良いのですが、指定しなくても勝手に微分してくれるので今回は横着します。</p>
<p>参考図書には、以下のガウス過程の予測分布の公式が記載されていますので、この公式に倣って予測分布を計算する自作関数を定義します。</p>
<p>$$
p(Y^{\star}|X^{\star},\mathcal{D}) = \rm{MultiNormal}(k_{\star}^T K^{-1}Y,k_{\star\star}-k_{\star}^{T}K^{-1}k_{\star})
$$</p>
<p>ここで$\mathcal{D}$は観測値$Y$、$X$の$N$個のペア、$Y^{\star}=(y_1^{\star},\ldots,y_M^{\star})$、$X^{\star}=(x_1^{\star}, \ldots, x_M^{\star})$はそれぞれ予測値と特徴ベクトル空間における予測したい点の$M$個のペアです。$k_{\star}$、$k_{\star\star}$はそれぞれ
$$
k_{\star}(n,m) = k(x_n,x_m^{\star})~~~(n=1,\ldots,N,m=1,\ldots,M)
$$
$$
k_{\star\star}(m_1,m_2) = k(x_{m1}^{\star},x_{m2}^{\star})~~~(m_1=1,\ldots,M, m_2=1,\ldots,M)
$$</p>
<p>を要素に持つカーネル行列です。</p>
<div class="highlight"><pre class="chroma"><code class="language-r" data-lang="r"><span class="c1"># 予測値の算出のための関数定義</span>
<span class="c1"># 返り値は各予測点の平均と共分散行列</span>
<span class="n">my_predict</span> <span class="o">&lt;-</span> <span class="nf">function</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">par</span><span class="p">){</span>
  <span class="n">kernel_cov_star</span> <span class="o">&lt;-</span> <span class="nf">function</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">par</span><span class="p">,</span><span class="n">kernel</span><span class="p">){</span>
    <span class="n">NL</span> <span class="o">&lt;-</span> <span class="nf">length</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
    <span class="n">ML</span> <span class="o">&lt;-</span> <span class="nf">length</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
    <span class="n">Sigma</span> <span class="o">&lt;-</span> <span class="nf">matrix</span><span class="p">(</span><span class="kc">NA</span><span class="p">,</span> <span class="n">nrow</span><span class="o">=</span><span class="n">NL</span><span class="p">,</span> <span class="n">ncol</span><span class="o">=</span><span class="n">ML</span><span class="p">)</span>
    <span class="nf">for</span><span class="p">(</span><span class="n">i</span> <span class="n">in</span> <span class="m">1</span><span class="o">:</span><span class="n">NL</span><span class="p">){</span>
      <span class="nf">for</span><span class="p">(</span><span class="n">j</span> <span class="n">in</span> <span class="m">1</span><span class="o">:</span><span class="n">ML</span><span class="p">){</span>
        <span class="n">Sigma[i</span><span class="p">,</span><span class="n">j]</span> <span class="o">&lt;-</span> <span class="nf">kernel</span><span class="p">(</span><span class="n">x1</span><span class="o">=</span><span class="n">x1[i]</span><span class="p">,</span> <span class="n">x2</span><span class="o">=</span><span class="n">x2[j]</span><span class="p">,</span><span class="n">par</span><span class="o">=</span><span class="n">par[</span><span class="o">-</span><span class="nf">length</span><span class="p">(</span><span class="n">par</span><span class="p">)</span><span class="n">]</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">return</span><span class="p">(</span><span class="n">Sigma</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="n">K</span> <span class="o">&lt;-</span> <span class="nf">kernel_cov</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="n">x_train</span><span class="p">,</span> <span class="n">par</span><span class="o">=</span><span class="n">par[</span><span class="o">-</span><span class="nf">length</span><span class="p">(</span><span class="n">par</span><span class="p">)</span><span class="n">]</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="n">par</span><span class="nf">[length</span><span class="p">(</span><span class="n">par</span><span class="p">)</span><span class="n">]</span><span class="p">)</span>
  <span class="n">k_star</span> <span class="o">&lt;-</span> <span class="nf">kernel_cov_star</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span> <span class="n">x1</span><span class="o">=</span><span class="n">x_train</span><span class="p">,</span> <span class="n">x2</span><span class="o">=</span><span class="n">x_test</span><span class="p">,</span><span class="n">par</span><span class="o">=</span><span class="n">par</span><span class="p">)</span>
  <span class="n">k_2star</span> <span class="o">&lt;-</span> <span class="nf">kernel_cov</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x_test</span><span class="p">,</span> <span class="n">par</span><span class="o">=</span><span class="n">par[</span><span class="o">-</span><span class="nf">length</span><span class="p">(</span><span class="n">par</span><span class="p">)</span><span class="n">]</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="n">par</span><span class="nf">[length</span><span class="p">(</span><span class="n">par</span><span class="p">)</span><span class="n">]</span><span class="p">)</span>
  <span class="n">mu</span> <span class="o">&lt;-</span> <span class="nf">t</span><span class="p">(</span><span class="n">k_star</span><span class="p">)</span> <span class="o">%*%</span> <span class="nf">solve</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="o">%*%</span> <span class="n">y_train</span>
  <span class="n">sigma</span> <span class="o">&lt;-</span> <span class="n">k_2star</span> <span class="o">-</span> <span class="nf">t</span><span class="p">(</span><span class="n">k_star</span><span class="p">)</span> <span class="o">%*%</span> <span class="nf">solve</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="o">%*%</span> <span class="n">k_star</span>
  <span class="nf">return</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div><h2 id="ガウスカーネルを使った回帰">ガウスカーネルを使った回帰</h2>
<p>上で定義した関数を使い、カーネル関数にガウスカーネルを設定して回帰を実行してみます。</p>
<div class="highlight"><pre class="chroma"><code class="language-r" data-lang="r"><span class="c1">#自作関数GP_L()を使って対数尤度を計算 対数尤度を最大化するハイパーパラメータを推定</span>
<span class="n">res_optim1</span> <span class="o">&lt;-</span> <span class="nf">optim</span><span class="p">(</span><span class="n">par</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">),</span><span class="n">fn</span><span class="o">=</span><span class="n">GP_L</span><span class="p">,</span><span class="n">kernel</span><span class="o">=</span><span class="n">Gaussian_kernel</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span><span class="n">control</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">fnscale</span><span class="o">=</span><span class="m">-1</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s">&#34;BFGS&#34;</span><span class="p">)</span>

<span class="n">par</span> <span class="o">&lt;-</span> <span class="nf">exp</span><span class="p">(</span><span class="n">res_optim1</span><span class="o">$</span><span class="n">par</span><span class="p">)</span>
<span class="c1"># 推定したパラメータの値を確認</span>
<span class="n">par</span>
<span class="c1">## [1] 1.55308949 0.22898734 0.04299662</span>

<span class="c1">#自作関数my_predict()を使って予測分布の平均・ 共分散行列を求める</span>
<span class="n">pre</span> <span class="o">&lt;-</span> <span class="nf">my_predict</span><span class="p">(</span><span class="n">x_test</span> <span class="o">=</span> <span class="nf">seq</span><span class="p">(</span><span class="m">-2.0</span><span class="p">,</span><span class="m">2.0</span><span class="p">,</span><span class="m">0.01</span><span class="p">),</span><span class="n">x_train</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y_train</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">Gaussian_kernel</span><span class="p">,</span><span class="n">par</span><span class="o">=</span><span class="n">par</span><span class="p">)</span>

<span class="c1"># 結果の描画</span>
<span class="nf">library</span><span class="p">(</span><span class="n">ggplot2</span><span class="p">)</span>
<span class="n">p</span> <span class="o">&lt;-</span> <span class="nf">ggplot</span><span class="p">()</span> <span class="o">+</span> <span class="nf">theme_bw</span><span class="p">(</span><span class="n">base_size</span><span class="o">=</span><span class="m">11</span><span class="p">)</span> <span class="o">+</span>
  <span class="nf">geom_line</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="nf">data.frame</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="nf">seq</span><span class="p">(</span><span class="m">-2.0</span><span class="p">,</span><span class="m">2.0</span><span class="p">,</span><span class="m">0.01</span><span class="p">),</span><span class="n">y</span><span class="o">=</span><span class="n">pre[[1]]</span><span class="p">),</span><span class="nf">aes</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">))</span>
<span class="n">p</span> <span class="o">&lt;-</span> <span class="n">p</span> <span class="o">+</span> <span class="nf">geom_point</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="nf">data.frame</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">),</span><span class="nf">aes</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">))</span>
<span class="n">p</span> <span class="o">&lt;-</span> <span class="n">p</span> <span class="o">+</span> <span class="nf">geom_ribbon</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="nf">data.frame</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="nf">seq</span><span class="p">(</span><span class="m">-2.0</span><span class="p">,</span><span class="m">2.0</span><span class="p">,</span><span class="m">0.01</span><span class="p">),</span><span class="n">ymin</span><span class="o">=</span><span class="n">pre[[1]]</span><span class="m">-2</span><span class="o">*</span><span class="nf">sqrt</span><span class="p">(</span><span class="nf">diag</span><span class="p">(</span><span class="n">pre[[2]]</span><span class="p">)),</span> <span class="n">ymax</span><span class="o">=</span><span class="n">pre[[1]]</span><span class="m">+2</span><span class="o">*</span><span class="nf">sqrt</span><span class="p">(</span><span class="nf">diag</span><span class="p">(</span><span class="n">pre[[2]]</span><span class="p">))),</span>
                     <span class="nf">aes</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">ymax</span><span class="o">=</span><span class="n">ymax</span><span class="p">,</span><span class="n">ymin</span><span class="o">=</span><span class="n">ymin</span><span class="p">),</span><span class="n">fill</span><span class="o">=</span><span class="s">&#34;blue&#34;</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="m">0.5</span><span class="p">)</span>
<span class="n">p</span>
</code></pre></div><p><img src="https://sucre-stat.com/r/gaussianprocess/res_1.png" alt=""></p>
<p>最適化したカーネル関数は以下になります。$\delta(x,x^{'})$はクロネッカーのデルタと呼ばれ、$x=x^{'}$のとき、つまりカーネル行列の対角成分にときのみ1を、それ以外は0を返す関数です。</p>
<p>$$
k(x,x_{'}) = 1.553exp\left(-\cfrac{(x-x^{'})^2}{0.229}\right) + 0.043\delta(x,x^{'})
$$</p>
<p>青い領域はガウス事後分布の$\pm2\sigma$の誤差範囲を示します。
<!-- raw HTML omitted -->  <br>
これまた不思議な予測曲線が得られました。結果を観察すると、観測値の乏しい範囲では誤差範囲が広く推定されており、期待値も平均($=0$)に近づくようになっています。</p>
<p>ハリボーはこう考えました。</p>
<p><strong>データの少ない部分は曖昧に推定するというのは、現実的な判断じゃあないか</strong>&gt;🦔</p>
<p>しかしかめきちはこう言っています。</p>
<p><strong>将来世界記録のタイムが伸びるという推定はあまりにもおかしいかめ</strong>&gt;🐢</p>
<h2 id="ガウスカーネル線形カーネルで回帰">ガウスカーネル＋線形カーネルで回帰</h2>
<p>かめきちの意見を踏まえ、カーネル関数でガウスカーネルと線形カーネルを組み合わせてみます。</p>
<div class="highlight"><pre class="chroma"><code class="language-r" data-lang="r"><span class="c1"># ガウスカーネル＋線形カーネを使って回帰</span>

<span class="c1"># 自作関数GP_L()を使って尤度を計算 尤度を最大化するハイパーパラメータを推定</span>
<span class="n">res_optim2</span> <span class="o">&lt;-</span> <span class="nf">optim</span><span class="p">(</span><span class="n">par</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">),</span><span class="n">fn</span><span class="o">=</span><span class="n">GP_L</span><span class="p">,</span><span class="n">kernel</span><span class="o">=</span><span class="n">Gaussian_plus_Linear_kernel</span><span class="p">,</span>
                 <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span><span class="n">control</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">fnscale</span><span class="o">=</span><span class="m">-1</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s">&#34;BFGS&#34;</span><span class="p">)</span>

<span class="n">par</span> <span class="o">&lt;-</span> <span class="nf">exp</span><span class="p">(</span><span class="n">res_optim2</span><span class="o">$</span><span class="n">par</span><span class="p">)</span>
<span class="c1"># 推定したパラメータの値を確認</span>
<span class="n">par</span>
<span class="c1">## [1] 0.11098682 0.02720031 0.46865763 0.04742707</span>

<span class="c1"># 自作関数my_predict()を使って予測分布の平均・ 共分散行列を求める</span>
<span class="n">pre</span> <span class="o">&lt;-</span> <span class="nf">my_predict</span><span class="p">(</span><span class="n">x_test</span> <span class="o">=</span> <span class="nf">seq</span><span class="p">(</span><span class="m">-2.0</span><span class="p">,</span><span class="m">2.0</span><span class="p">,</span><span class="m">0.01</span><span class="p">),</span><span class="n">x_train</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y_train</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
                  <span class="n">kernel</span> <span class="o">=</span> <span class="n">Gaussian_plus_Linear_kernel</span><span class="p">,</span><span class="n">par</span><span class="o">=</span><span class="n">par</span><span class="p">)</span>

<span class="c1"># 結果の描画</span>
<span class="nf">library</span><span class="p">(</span><span class="n">ggplot2</span><span class="p">)</span>
<span class="n">p</span> <span class="o">&lt;-</span> <span class="nf">ggplot</span><span class="p">()</span> <span class="o">+</span> <span class="nf">theme_bw</span><span class="p">(</span><span class="n">base_size</span><span class="o">=</span><span class="m">11</span><span class="p">)</span> <span class="o">+</span>
  <span class="nf">geom_line</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="nf">data.frame</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="nf">seq</span><span class="p">(</span><span class="m">-2.0</span><span class="p">,</span><span class="m">2.0</span><span class="p">,</span><span class="m">0.01</span><span class="p">),</span><span class="n">y</span><span class="o">=</span><span class="n">pre[[1]]</span><span class="p">),</span><span class="nf">aes</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">))</span>
<span class="n">p</span> <span class="o">&lt;-</span> <span class="n">p</span> <span class="o">+</span> <span class="nf">geom_point</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="nf">data.frame</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">),</span><span class="nf">aes</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">))</span>
<span class="n">p</span> <span class="o">&lt;-</span> <span class="n">p</span> <span class="o">+</span> <span class="nf">geom_ribbon</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="nf">data.frame</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="nf">seq</span><span class="p">(</span><span class="m">-2.0</span><span class="p">,</span><span class="m">2.0</span><span class="p">,</span><span class="m">0.01</span><span class="p">),</span><span class="n">ymin</span><span class="o">=</span><span class="n">pre[[1]]</span><span class="m">-2</span><span class="o">*</span><span class="nf">sqrt</span><span class="p">(</span><span class="nf">diag</span><span class="p">(</span><span class="n">pre[[2]]</span><span class="p">)),</span> <span class="n">ymax</span><span class="o">=</span><span class="n">pre[[1]]</span><span class="m">+2</span><span class="o">*</span><span class="nf">sqrt</span><span class="p">(</span><span class="nf">diag</span><span class="p">(</span><span class="n">pre[[2]]</span><span class="p">))),</span>
                     <span class="nf">aes</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">ymax</span><span class="o">=</span><span class="n">ymax</span><span class="p">,</span><span class="n">ymin</span><span class="o">=</span><span class="n">ymin</span><span class="p">),</span><span class="n">fill</span><span class="o">=</span><span class="s">&#34;blue&#34;</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="m">0.5</span><span class="p">)</span>
<span class="n">p</span>
</code></pre></div><p><img src="https://sucre-stat.com/r/gaussianprocess/res_2.png" alt=""></p>
<p><strong>It&rsquo;s so brilliant</strong>&gt;🐢</p>
<p>最適化したカーネル関数は以下になります。</p>
<p>$$
k(x,x_{'}) = 0.111exp\left(-\cfrac{(x-x^{'})^2}{0.027}\right) + 0.469x^T x^{'} + 0.047\delta(x,x^{'})
$$</p>
<p>タイムが短縮される全体的な傾向が線形カーネルでとらえるとともに、細かい変動をガウスカーネルで表現できています。</p>
<p>勾配法の初期値を変えるとどうなるでしょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-r" data-lang="r"><span class="n">res_optim3</span> <span class="o">&lt;-</span> <span class="nf">optim</span><span class="p">(</span><span class="n">par</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">0.4</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">),</span><span class="n">fn</span><span class="o">=</span><span class="n">GP_L</span><span class="p">,</span><span class="n">kernel</span><span class="o">=</span><span class="n">Gaussian_plus_Linear_kernel</span><span class="p">,</span>
                 <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span><span class="n">control</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">fnscale</span><span class="o">=</span><span class="m">-1</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s">&#34;BFGS&#34;</span><span class="p">)</span>
<span class="n">par</span> <span class="o">=</span> <span class="nf">exp</span><span class="p">(</span><span class="n">res_optim3</span><span class="o">$</span><span class="n">par</span><span class="p">)</span>
<span class="n">par</span>
<span class="c1">## [1] 0.22313442 2.81135418 0.50883359 0.09808983</span>

<span class="o">~</span>省略<span class="o">~</span>
</code></pre></div><p><img src="https://sucre-stat.com/r/gaussianprocess/res_3.png" alt=""></p>
<p>最適化したカーネル関数は以下になります。</p>
<p>$$
k(x,x_{'}) = 0.223exp\left(-\cfrac{(x-x^{'})^2}{2.811}\right) + 0.509x^T x^{'} + 0.098\delta(x,x^{'})
$$</p>
<p>ハイパーパラメータの値が変化し、結果も全く異なります。勾配法によるハイパーパラメータ推定では初期値によって結果が異なることも多く、局所最適解が多い場合はその傾向が強いです。
<!-- raw HTML omitted -->  <br>
このような場合、MCMCで推定すると大域的局所解に近づいてくれます。</p>
<h2 id="情報量基準の確認">情報量基準の確認</h2>
<p>モデルの良さを表す数値的指標として、各種の<strong>情報量基準</strong>が提案されています。
ここでは、以下で定義される<strong>AIC</strong>を計算してみます。
(AICは正しい使い方というのがあるようで私はAICを誤用しているかもしれません。誤りがあればご指摘を！)</p>
<p>$$
AIC = -2最大対数尤度＋2自由パラメータの個数
$$</p>
<div class="highlight"><pre class="chroma"><code class="language-r" data-lang="r"><span class="c1"># optim()で対数尤度にマイナスをかけているので、ここでは対数尤度にマイナスをかけない</span>
<span class="c1"># optim()で最大化したGP_L()は、実際の対数尤度ではなく対数尤度に比例する値なので、ここで正確な対数尤度を計算する</span>
<span class="n">my_AIC</span> <span class="o">&lt;-</span> <span class="nf">function</span><span class="p">(</span><span class="n">res_optim</span><span class="p">,</span> <span class="n">x</span><span class="p">){</span>
  <span class="nf">return</span><span class="p">(</span><span class="m">2</span><span class="o">*</span><span class="p">(</span><span class="n">res_optim</span><span class="o">$</span><span class="n">value</span><span class="o">/</span><span class="m">2</span> <span class="o">+</span> <span class="nf">length</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="m">2</span> <span class="o">*</span> <span class="nf">log</span><span class="p">(</span><span class="m">2</span><span class="o">*</span><span class="kc">pi</span><span class="p">))</span><span class="m">+2</span><span class="o">*</span><span class="nf">length</span><span class="p">(</span><span class="n">res_optim</span><span class="o">$</span><span class="n">par</span><span class="p">))</span>
<span class="p">}</span>
<span class="nf">cat</span><span class="p">(</span><span class="nf">sprintf</span><span class="p">(</span><span class="s">&#34;AIC of \n res1 = %.3f\n res2 = %.3f\n res3 = %.3f&#34;</span><span class="p">,</span><span class="nf">my_AIC</span><span class="p">(</span><span class="n">res_optim1</span><span class="p">,</span><span class="n">x</span><span class="p">),</span> <span class="nf">my_AIC</span><span class="p">(</span><span class="n">res_optim2</span><span class="p">,</span><span class="n">x</span><span class="p">),</span> <span class="nf">my_AIC</span><span class="p">(</span><span class="n">res_optim3</span><span class="p">,</span><span class="n">x</span><span class="p">)))</span>

<span class="c1">## AIC of</span>
<span class="c1">##  res1 = 60.507</span>
<span class="c1">##  res2 = 68.203</span>
<span class="c1">##  res3 = 65.642</span>
</code></pre></div><p>AICは、小さい値をとるモデルほど良いモデルと考えます。結果を見ると、一番初めのガウスカーネルを使ったモデルが最もAICが小さいです。また、ガウスカーネル・線形カーネルの２モデルの比較では、後のモデルの方がAICが小さいです。</p>
<p>これらの結果から、ガウスカーネルを使ったモデルが最も良いモデルであることが示唆されますが、AICはほかのモデルを完全否定するものではないので、最終的にどのモデルを選択するかは技術者判断と言えます。</p>
<p>私としては最後の結果を支持したいところです…。</p>
<h1 id="まとめ">まとめ</h1>
<p>今回はガウス過程について説明しました。ガウス過程は理論が難しいですが、結果が合理的で、黒魔術かと疑ってしまうような技術です。
<!-- raw HTML omitted -->  <br>
その応用範囲も広く、空間統計の分野では割と以前から活用されていたようです。また構造計算で利用される有限要素法においてもデータを完璧に補間するモデルとして広く利用されているそうです。</p>
<p>私はこれまで以下の活用方法を確認しています。</p>
<ul>
<li>一般化線形モデルの線形予測子をガウス過程に置き換え、柔軟なモデルに豹変させる</li>
<li>空間統計において空間的自己相関を考慮したモデルを構築する</li>
</ul>
<p>ちなみにガウス過程を一般化線形モデルに活用したりするような場合、事後分布は単純なガウス分布ではないため、MCMC等の近似推論法が必要となります。<strong>私の大好きなMCMCです。</strong></p>
<p>また、大規模データに対しガウス過程を含むモデルを素直に計算すると、計算量が膨大となってしまいます。そのため、様々な近似手法が提案されているようです。参考図書の後半でその近似手法が述べられているので今後勉強したいと思っています。</p>
<p>ガウス過程の活用例も今後の記事で紹介できればと思っています。楽しみ。</p>

        </article>
    </div>
    <div class="main-content__tags u-font">
        
        
        <span><a href="https://sucre-stat.com/tags/%E5%9B%9E%E5%B8%B0">回帰</a></span>
        
        <span><a href="https://sucre-stat.com/tags/%E3%82%AC%E3%82%A6%E3%82%B9%E9%81%8E%E7%A8%8B">ガウス過程</a></span>
        
        
    </div>

    <div class="contact_form">
        <form
                className='sampleCommentForm'
                name="sampleCommentForm"
                method="POST"
                action="thank-you"
                data-netlify-recaptcha="true"
                data-netlify="true"
                action=""
          netlify>
        <p>コメントを書く</p>
            <label>お名前: <input type="text" name="name" /></label>
            <label>Email(任意): <input type="email" name="email" /></label>
            <label>コメント: <textarea name="content"></textarea></label>
          <p style="display:none;">
            <label>Bot Field(ここに値が入るとスパム判定する): <input name="bot-field"/></label>
          </p>
          <div data-netlify-recaptcha="true"></div>
          <div>
            <button type="submit" value="Send">送信</button>
            <p><br>※ コメントは承認されると表示されます<br></p>
            <input type="hidden" name="path" value="/2020/06/gaussianprocess/index.html" />
            <p>承認されたコメント一覧</p>
            <ul class="comment" id="approvalCommentsList"></ul>
        
          </div>
        </form>
    </div>

    
    <script src="//cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script language="javascript" type="text/javascript">
    
    const url = '/comment/_data/sampleApprovedComments_submissions.json'
    $.getJSON(url, (json) => {
      for (let i = 0; i < json.length; i++) {
        if (json[i].data.path !== '\/2020\/06\/gaussianprocess\/index.html') {
          continue
        }
        $('#approvalCommentsList').append(`<li>お名前　： ${json[i].data.name}<br>コメント： ${json[i].data.content}</li>`)
      }
    })

    // 送信前に一言感謝
    $("#my-form").submit(function(e) {
      alert("Thank you!");
    });
    </script>
</div>

<div class="main-profile">
    <div class="main-profile__avatar">
        
            <img src="https://sucre-stat.com/images/avatar.JPG">
        
    </div>
    <div class="main-profile__body">
        <div class="main-profile__author">
            
            <span> R.morita </span>
            
        </div>
        <div class="main-profile__description">
            
            <p> 得意なのは統一された洋服とダンスのステップです </p>
            
        </div>
    </div>
</div>
<div class="main-line"></div>
<div class="main-pn">
    
    <a class="previous" href="https://sucre-stat.com/2020/05/multinom-rstan/">
        <div class="pn-dec"></div>
        <div class="pn-els">
            <div class="pn-el__1"> 2020.05.31 00:00 </div>
            <div class="pn-el__2"> rstanを使った多項ロジスティック回帰 </div>
        </div>
    </a>
    
    
    <a class="next" href="https://sucre-stat.com/2020/07/multinom-gp/">
        <div class="pn-dec"></div>
        <div class="pn-els">
            <div class="pn-el__1"> 2020.07.12 00:00 </div>
            <div class="pn-el__2"> 多項ロジスティック回帰・ガウス過程モデル </div>
        </div>
    </a>
    
</div>

<footer>
  <script type="text/javascript">
 MathJax = {
   tex: {
     inlineMath: [['$','$'], ['\\(','\\)']],
     processEscapes: true,
     tags: "ams",
     autoload: {
       color: [],
       colorV2: ['color']
     },
     packages: {'[+]': ['noerrors']}
   },
   chtml: {
     matchFontHeight: true,
     displayAlign: "left",
     displayIndent: "2em"
   },
   options: {
     skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
     renderActions: {
        
       find_script_mathtex: [10, function (doc) {
         for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
           const display = !!node.type.match(/; *mode=display/);
           const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
           const text = document.createTextNode('');
           node.parentNode.replaceChild(text, node);
           math.start = {node: text, delim: '', n: 0};
           math.end = {node: text, delim: '', n: 0};
           doc.math.push(math);
         }
       }, '']
     }
   },
   loader: {
     load: ['[tex]/noerrors']
   }
 };
</script>
<script type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" id="MathJax-script"></script>
</footer>

</div>
<div class="footer">
    <div class="copyright-wrap">
        <p class="copyright u-font">
            
            &#169;
            2021
            
            <a href="https://github.com/Rmorita-stat/doc" target="_blank">R.morita&#46;</a>
            Theme <a href="https://github.com/iCyris/hugo-theme-yuki" target="_blank">yuki</a>&#46;
            Powered by Hugo&#46;
            
            
        </p>
    </div>
</div>
</body>
<script src="https://sucre-stat.com/js/page.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

