<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>
        
        SUCRE HECACHA
        
    </title>
    <meta name="viewport" id="viewport" content="width=device-width, initial-scale=1">
    <link rel='icon' type='image/x-icon' href="https://rmorita-stat.github.io/my-page/images/logo2.png" />
    <link rel="apple-touch-icon" href="https://rmorita-stat.github.io/my-page/images/logo2.png"><link rel="stylesheet" href="https://rmorita-stat.github.io/my-page/scss/style.css">
    
    <link rel="stylesheet" href="https://rmorita-stat.github.io/my-page/scss/monokai-sublime.min.css">
    <script src="https://rmorita-stat.github.io/my-page/js/highlight.min.js"></script>
    <link rel="stylesheet" href="https://rmorita-stat.github.io/scss/highlight.css">
    
    <link rel="stylesheet" href="https://rmorita-stat.github.io/scss/custom.css">
    
    
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'Your Google Analytics tracking id', 'auto');
        ga('send', 'pageview');
    </script>
    
    
    <meta name="generator" content="Hugo 0.71.0" /></head>


<body>
<div class="header">
    <div class="site-logo__wrap">
        <div id="site-button">
            <div></div>
        </div>
        
        <div class=' site-logo '>
            <a href="https://rmorita-stat.github.io/my-page/"><img src="https://rmorita-stat.github.io/my-page/images/logo.png" /></a>
        </div>
    </div>
    
<div class=' site-nav u-font ' id="nav-bar">
    
    <div class="site-nav__wrap">
        <a class="site-nav__el" href="/my-page/" >HOME</a>
    </div>
    
    <div class="site-nav__wrap">
        <a class="site-nav__el" href="/my-page/post" >BLOG</a>
    </div>
    
    <div class="site-nav__wrap">
        <a class="site-nav__el" href="/my-page/about" >ABOUT</a>
    </div>
    
    <div class="site-nav__wrap">
        <a class="site-nav__el" href="/my-page/tags/" >TAGS</a>
    </div>
    
</div>

</div>
<div class="main">

<div class="main-content">
    <div class="main-content__date">
        <h4 id="date"> 0001.01.01 00:00 </h4>
    </div>
    <div class="main-content__title">
        <h1 id="title">対応分析の同時付置にベイズ信頼区間をもたせる</h1>
    </div>
    <div class="main-content__article">
        <article id="content">
            <h1 id="はじめに">はじめに</h1>
<p>この記事は<a href="https://qiita.com/advent-calendar/2020/stan">Stan Advent calendar</a>12月12日にエントリーしている記事です。</p>
<p>この記事では多変量解析の一つである<strong>対応分析</strong>を題材にします。</p>
<p>対応分析は多変量のカテゴリカルデータに用いられる分析で、クロス集計表の結果を視覚的に表現するために使われる統計的手法です。</p>
<p>実は対応分析は私の修士研究で使用した解析手法なのですが、対応分析の付置はデータ数に依存しないことから、座標を得るだけでその信頼性が確認できないところに当時問題を感じていました。<br>
大学を卒業してからベイズ統計に関心を持ち、ある程度勉強したところで当時のことを思い出し、<strong>rstan</strong>を使ってこの問題に取り組もうと思ったのが本記事の執筆動機です。</p>
<p>本記事の構成は以下のとおりとします。</p>
<!-- raw HTML omitted -->
<ul>
<li><a href="#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB">はじめに</a></li>
<li><a href="#%E5%AF%BE%E5%BF%9C%E5%88%86%E6%9E%90%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">対応分析について</a></li>
<li><a href="#%E5%AF%BE%E5%BF%9C%E5%88%86%E6%9E%90%E3%81%AE%E5%90%8C%E6%99%82%E4%BB%98%E7%BD%AE%E5%9B%B3%E3%81%AF%E4%BF%A1%E9%A0%BC%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%AE%E3%81%8B">対応分析の同時付置図は信頼できるのか</a>
<ul>
<li><a href="#%E4%BB%98%E7%BD%AE%E3%81%AF%E6%A8%99%E6%9C%AC%E6%95%B0%E3%81%AB%E4%BE%9D%E3%82%89%E3%81%AA%E3%81%84">付置は標本数に依らない？</a></li>
<li><a href="#%E5%88%86%E5%89%B2%E8%A1%A8%E3%81%AE%E4%B8%80%E6%A7%98%E6%80%A7%E3%81%AE%E6%A4%9C%E5%AE%9A">分割表の一様性の検定</a></li>
<li><a href="#%E5%90%8C%E6%99%82%E4%BB%98%E7%BD%AE%E5%9B%B3%E3%81%A8%E4%B8%80%E6%A7%98%E6%80%A7%E3%81%AE%E5%B8%B0%E7%84%A1%E4%BB%AE%E8%AA%AC%E3%81%AE%E9%96%A2%E4%BF%82">同時付置図と一様性の帰無仮説の関係</a></li>
</ul>
</li>
<li><a href="#%E3%83%A2%E3%83%87%E3%83%AB%E4%BD%9C%E6%88%90">モデル作成</a>
<ul>
<li><a href="#%E5%88%86%E5%89%B2%E8%A1%A8%E3%81%AE%E3%83%A2%E3%83%87%E3%83%AA%E3%83%B3%E3%82%B0">分割表のモデリング</a></li>
<li><a href="#mcmc%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AB%E3%82%88%E3%82%8A%E7%94%9F%E6%88%90%E9%87%8F%E3%82%92%E5%BE%97%E3%82%8B%E5%80%A4">MCMCサンプルより生成量を得る値</a>
<ul>
<li><a href="#%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E3%81%AE%E5%AF%BE%E8%B1%A1x">主成分分析の対象$X$</a></li>
<li><a href="#%E5%9B%BA%E6%9C%89%E3%83%99%E3%82%AF%E3%83%88%E3%83%ABl_k">固有ベクトル$l_k$</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E3%83%A2%E3%83%87%E3%83%AB%E3%81%AE%E5%AE%9F%E8%A3%85">モデルの実装</a></li>
<li><a href="#%E7%B5%90%E6%9E%9C%E3%81%AE%E7%A2%BA%E8%AA%8D">結果の確認</a></li>
<li><a href="#%E3%81%8A%E3%81%BE%E3%81%91%E7%A7%81%E3%81%8C%E7%9B%B8%E6%92%B2%E3%81%AB%E5%8F%82%E5%8A%A0%E3%81%99%E3%82%8B%E3%81%A8">おまけ～私が相撲に参加すると？～</a></li>
<li><a href="#%E3%81%BE%E3%81%A8%E3%82%81">まとめ</a></li>
</ul>
<!-- raw HTML omitted -->
<p>参考にした論文は前回と同様の<a href="https://www.jstage.jst.go.jp/article/jscswabun/7/2/7_KJ00002502205/_article/-char/ja/">こちら</a>です。  <br>
この論文はもうだいぶ古いですが、既に対応分析の付置の信頼性の問題を解決してくれています。ただし解析的な正規分布への近似をもとに信頼区間を求めているようなので、本記事ではこの論文とは別のベイズ的なアプローチをとることにします。</p>
<h1 id="対応分析について">対応分析について</h1>
<p>対応分析とはクロス集計表など、カテゴリカルな行と列のデータを視覚的に表現することで、項目間の関係を把握しようとする手法です。コレスポンデンス分析とも呼ばれ、数理的には林先生の数量化理論第Ⅲ類と同等のものとされています。<br>
対応分析の数理的な内容については、<a href="https://rmorita-stat.github.io/my-page/post/correspondencenalysis/correspondenceanalysis/">前回の記事</a>で説明しているのでそちらを見てください。<br>
ここでは対応分析の同時付置図の信頼性について考えてみます。</p>
<h1 id="対応分析の同時付置図は信頼できるのか">対応分析の同時付置図は信頼できるのか</h1>
<h2 id="付置は標本数に依らない">付置は標本数に依らない？</h2>
<p><a href="https://rmorita-stat.github.io/my-page/post/correspondencenalysis/correspondenceanalysis/#%E5%AF%BE%E5%BF%9C%E5%88%86%E6%9E%90%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">前回の記事</a>を振り返り、対応分析について復習します。</p>
<p>$i$行$m$列が$f_{ij}$（$i=1 … M$、$j = 1 … N$）である$M$行$N$列$(M&gt;N)$の分割表について考えたとき、対応分析の同時付置図作成までの過程は以下のようになっていました。<br>
なお各行・列および全項目の総和を前回と同様以下のように表記します。</p>
<p>$$
f_{i.} = ∑_{j=1}^{N}f_{ij} ~,~~ f_{.j} = ∑_{i=1}^{M}f_{ij} ~,~~ Sum = ∑_{j=1}^{N} ∑_{i=1}^{M} f_{ij}
$$</p>
<ol>
<li>確率行列$P_I = diag \left[ p_{1.}, …, p_{M.} \right]$（$p_{i.} = f_{i.}/Sum$）、$P_J = diag \left[ p_{.1}, …, p_{.N} \right]$（$p_{.j} = f_{.j}/Sum$）、$P_{ij}=\left(f_{ij}/N\right)$より$M$行$N$列の行列$X$を作成する。</li>
<li>$X$の主成分分析を計算し、最大固有値から順に$\lambda_{1},\lambda_{2}\ldots,\lambda_{N-1}$、およびこれらに対応する固有ベクトル$l_1,l_2,\ldots,l_{N-1}$を得る<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。</li>
<li>第$k$主成分ベクトル$l_k$による項目$I$の数量化スコア$z_{k} = (z_{1k}, \ldots, z_{Nk})$を下記式より計算する。
$$
z_k = Xl_k = P_I^{-1}P_{IJ}P_{J}^{-1/2}l_k \tag{1}
$$</li>
<li>項目$J$の数量化スコアを、下記式に基づき項目$I$の数量化スコアから求める。
$$
z_k^* = \cfrac{1}{\sqrt{λ_k}}P_J^{-1}P_{IJ}z_k \tag{2}
$$</li>
<li>$z_k$、$z^{*}_k$をもとに行項目・列項目の同時付置図を作成する。</li>
</ol>
<p>ここで、$(1)$$(2)$式を見ると、<strong>すべての数量化スコアが確率行列のみに依存しており、標本数$Sum$に影響されない</strong>ことが確認できます。つまり、標本数が違う2つの分割表があったとして、それらの確率行列$P_{IJ}$が一致する場合、同時付置図は全く同じものになると…<br>
よって、同時付置図はそれのみでは付置がどの程度信頼できるかが確認できないようになっているのです。</p>
<h2 id="分割表の一様性の検定">分割表の一様性の検定</h2>
<p>上記問題の解決というわけではないですが、<strong>分割表の一様性の検定</strong>というものがありまして、分割表の各行の確生起確率$(p_{i1},\ldots,p_{iN})$が同じであるといえるかどうかを判定する検定があります。分割表の検定の結果下に述べる帰無仮説が棄却された場合、対応分析により、存在すると考えられる生起確率の差の傾向を把握できるだろう、というわけです<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>。</p>
<p>この検定の帰無仮説は<br>
<!-- raw HTML omitted -->$H_0$：すべての$1 \leq j&lt; N$に対して、$\cfrac{f_{ij}}{f_{i.}} = p_{.j}$<!-- raw HTML omitted --><br>
で<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>、検定統計量は</p>
<p>$$
T = ∑_{i=1}^{M}∑_{j=1}^{N}\cfrac{\left(f_{ij} - f_{i.}p_{.j}\right)^2}{f_{i.}p_{.j}} \tag{3}
$$</p>
<p>です。$T$が漸近的に自由度$(M-1)(N-1)$の$χ^2$分布に従うことを用いて検定を行います。<br>
試しに前回の記事と同じ相撲データについて一様性の検定をしてみましょう。</p>
<pre><code># smo_dataの作成 ----------------------------------------------------------

smo_data &lt;- matrix(data=c(15,15,0,0,1,0,1,19,9,7,12,1,3,3,4,22,0,11,2,0,4,
                          14,3,11,3,1,1,6,24,7,5,5,0,0,2,30,2,6,2,2,0,2,
                          11,13,5,6,2,1,4,25,8,10,7,5,3,1,13,31,3,3,0,2,3,
                          8,2,19,3,2,0,4,28,8,8,2,1,0,7,9,3,14,11,2,0,4,
                          5,3,12,11,4,0,7,7,1,18,0,1,0,11,12,6,1,12,7,2,2,
                          25,2,11,3,1,0,1,16,4,18,3,0,0,5,23,2,6,5,1,0,2,
                          7,17,2,16,3,0,1,2,8,1,11,1,0,2),byrow=TRUE, ncol=7)

colnames(smo_data) &lt;- c(&quot;寄り&quot;,&quot;押し&quot;,&quot;投げ&quot;,&quot;引き&quot;,&quot;送り&quot;,&quot;突き&quot;,&quot;その他&quot;)
rownames(smo_data) &lt;- c(&quot;小錦&quot;,&quot;琴錦&quot;,&quot;貴闘力&quot;,&quot;霧島&quot;,&quot;栃ノ和歌&quot;,&quot;水戸錦&quot;,&quot;若ノ花&quot;,&quot;貴ノ花&quot;,&quot;武蔵丸&quot;,
                        &quot;大翔山&quot;,&quot;安芸ノ島&quot;,&quot;三杉里&quot;,&quot;旭道山&quot;,&quot;舞の海&quot;,&quot;寺尾&quot;,&quot;琴の若&quot;,&quot;貴ノ浪&quot;,
                        &quot;琴富士&quot;,&quot;隆三杉&quot;,&quot;春日富士&quot;)

# smo_dataの一様性検定 ----------------------------------------------------------

my_uniformity_test &lt;- function(data){
  data_teststat &lt;- matrix(NA, nrow=nrow(data), ncol=ncol(data))
  p_j &lt;- rep(NA, length=n)
  for(j in 1:n){
    p_j[j] &lt;- sum(data[,j])/sum(data)
  }
  for(i in 1:m){
    for(j in 1:n){
      data_teststat[i,j] &lt;- (data[i,j] - rowSums(data)[i]*p_j[j])^2 / (rowSums(data)[i]*p_j[j])
    }
  }
  T_stat &lt;- sum(data_teststat)
  cat(sprintf(&quot;p-value:%.5f&quot;,pchisq(T_stat, df=((m-1)*(n-1)), lower.tail = FALSE)))
}

my_uniformity_test(smo_data)
## p-value:0.00000
</code></pre><p>帰無仮説は有意水準0.1%以下で棄却されました。では、このデータの各度数を4分の1にしたデータではどうでしょうか<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>。</p>
<pre><code>my_uniformity_test(smo_data/4)
## p-value:0.39973
</code></pre><p>p値は約0.4ですので、とても帰無仮説を棄却できません。<br>
そんな訳なので、同じ付置図が得られても標本数によって信頼性に差があるため、付置図だけからは正しい解釈ができない可能性があるんです。</p>
<h2 id="同時付置図と一様性の帰無仮説の関係">同時付置図と一様性の帰無仮説の関係</h2>
<p>対応分析の同時付置図がどのようになっているときに一様性の帰無仮説が棄却されやすいかを、説明します。</p>
<p>生起確率が全体の平均に等しく$(p_{.1},\ldots,p_{.n})$である個体$i$の第$k$数量化スコアは、</p>
<p>$$
\left(\cfrac{p_{i1}}{p_{i1}\sqrt{p_{.1}}},\ldots,\cfrac{p_{iN}}{p_{i1}\sqrt{p_{.N}}}\right)^T l_k = \cfrac{1}{p_{i.}}\left(\sqrt{p_{.1}},\ldots,\sqrt{p_{.N}}\right)^T l_k = 0 \tag{4}
$$</p>
<p>なので<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>、<strong>同時付置図の原点が帰無仮説に対応する点</strong>になっています。</p>
<p>また、$(3)$式を展開すると、</p>
<p>$$
T = ∑_{i=1}^{M}∑_{j=1}^{N} f_{i.}\cfrac{\left(\cfrac{p_{ij}}{p_{i.}}-p_{.j}\right)^2}{p_{.j}}
=  ∑_{i=1}^{M}f_{i.}∑_{j=1}^{N}\cfrac{\left(\cfrac{p_{ij}}{p_{i.}}-p_{.j}\right)^2}{p_{.j}} \tag{5}
$$</p>
<p>となることから、<strong>帰無仮説の点（同時付置図の原点）から離れている行$i$で、行和$f_i$が大きいものがある場合に$T$が大きくなり、一様性の帰無仮説が棄却されやすい</strong><sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup>ことが分かります。</p>
<p>以上を踏まえ、同時付置図にそれぞれのポイントの信頼度を表示することができれば、視覚的な結果の解釈や項目の分類の手助けになるのでは、というのが本記事の狙いです。</p>
<h1 id="モデル作成">モデル作成</h1>
<p>分割表の生成過程にモデルを設定し、MCMCによってモデルのパラメータを推定し、同時付置図における各ポイントの信頼区間（または予測区間）を求めることを考えます<sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup>。</p>
<h2 id="分割表のモデリング">分割表のモデリング</h2>
<p>分割表の生成過程は、分割表の性質により以下の2パターンのいずれかを仮定することができます。</p>
<ul>
<li>観測度数の総和が固定されており、全観測度数がひとつの多項分布に従うとする仮定</li>
<li>各行の総和が固定されており、各行の観測度数が独立の多項分布に従うとする仮定</li>
</ul>
<p>対応分析にかける分割表の場合、後者の場合が多いかと思います。一様性の検定の際にも、後者の仮定を設定して、検定をしていました。</p>
<p>$$
\left(f_{i1},\ldots,f_{iN}\right) \sim Multinom(f_{i.}
, Θ_i ) \tag{6}
$$
$$
\Theta_{i} = (\theta_{i1},\ldots,, θ_{iN}) \tag{7}
$$
$$
∑_{j=1}^{N}\theta_{ij} = 1 \tag{8}
$$
$$
i=1,\ldots,M
$$</p>
<p>$(6)$式とデータによる尤度に基づいたMCMCにより、各行ごとの観測度数の生成確率$\Theta_{i}$の事後分布及びMCMCサンプルが得られます。<br>
観測度数の行の総和$F_{i.}$が小さい行の$\Theta_{i}$ほど、事後分布の推定幅が広くなります。このMCMCサンプルに対する主成分ベクトルの射影を得ることで、同時付置図における項目$I$（行項目）の各ポイントの信頼区間を表示できると考えられます。</p>
<p>項目$J$（列項目）についても、各列の観測度数に独立の多項分布を仮定することで、各ポイントの座標について信頼区間が得られると考えられますが、今回の実装では項目$J$を変量とみなし、列毎の観測度数の総和は試行ごとに一定でないと考えるので、列毎に独立の多項分布を仮定しない（列項目のポイントの座標の信頼区間は求めない）ことにします<sup id="fnref:8"><a href="#fn:8" class="footnote-ref" role="doc-noteref">8</a></sup>。</p>
<h2 id="mcmcサンプルより生成量を得る値">MCMCサンプルより生成量を得る値</h2>
<p>対応分析の分析過程のなかのどの数値に対し、MCMCサンプルより生成量を得るかを考えます。$(1)$式より、座標は$X$及び固有ベクトル$l_k$ により計算されますから、それぞれについて考えます。</p>
<h3 id="主成分分析の対象x">主成分分析の対象$X$</h3>
<p>行列$X$のなかでも、第$k$数量化スコアの計算では$\left(\cfrac{p_{i1}}{p_{i1}\sqrt{p_{.1}}},\ldots,\cfrac{p_{iN}}{p_{i1}\sqrt{p_{.N}}}\right)^T$が関係しますから、生成量を得る候補は$p_{ij}$と$p_{.j}$です。</p>
<p>このうち、$p_{ij}$については、期待値$θ_{ij}$もしくは$Multinom(f_{i.}, \Theta_{i})$からの乱数を用いて生成量を得ることにしましょう。</p>
<p>$p_{.j}$についてですが、これの生成量を得ようとすると、$\theta_{1,j},\ldots,\theta_{Mj}$の$m$個のMCMCサンプルがかかわってきてしまいます。考え方は色々あると思いますが、ここでは各行が統計的に独立であることを踏まえて、個体$i$の同時付置図の信頼区間には、個体$i$の従う多項分布のパラメータ$\Theta_i$の影響しか反映させないものとし、$(9)$の行列から$p_{,j}$を計算することにしましょう<sup id="fnref:9"><a href="#fn:9" class="footnote-ref" role="doc-noteref">9</a></sup>。</p>
<p>以上の操作について、後述の実装では、$i$行目の項目の座標を得る際には$(9)$の行列をもとに$X$を計算し、各主成分ベクトルによる射影を得ることにします。</p>
<p>$$
\left(
\begin{array}{ccc}
f_{11} &amp; f_{12} &amp; \cdots &amp; f_{1N} \\<br>
\vdots &amp; \vdots &amp;  &amp; \vdots \\<br>
\theta_{i1}f_{i.} &amp; \theta_{i2}f_{i.} &amp; \cdots &amp; \theta_{iN}f_{i.} \\<br>
\vdots &amp; \vdots &amp; &amp; \vdots \\<br>
f_{M1} &amp; f_{M2} &amp; \cdots &amp; f_{MN}
\end{array}\right) \tag{9}
$$</p>
<h3 id="固有ベクトルl_k">固有ベクトル$l_k$</h3>
<p>分割表の生成過程のモデリングにより、各セルの観測度数の期待値がMCMCサンプルとして得らます。それらをもとに新しい分割表を生成し、新たに主成分ベクトルを得ることができるにはできるのですが、そうすると軸がMCMCサンプル毎に異なってしまいます。最終的に作成する同時付置図は軸を固定して示したいのでこれは不都合です。</p>
<p>本記事のモデルでは、観測値を真の値とみなすのと同様に、<strong>観測値から得られた主成分ベクトルを真のベクトルであるとみなし、同時付置図も観測値から計算された主成分ベクトル上で付置する</strong>ものとします。固有値や寄与率についても同様に観測値から計算された値を真の値とします。</p>
<h1 id="モデルの実装">モデルの実装</h1>
<p>以上のモデルを実装したStanコードを載せます。</p>
<p><code>data{}</code>ブロックでは分割表に関する数値を指定するだけです。</p>
<p><code>transformed data{}</code>ブロックでは対応分析の計算をしています。外で計算して得た主成分ベクトルや固有値をdataブロックで指定するやり方もありましたが、Stan内で計算してみました。<br>
固有値・固有ベクトルを計算する<code>eigenvalues_sym</code>関数と<code>eigenvectors_sym</code>関数は、最小固有値から順にオブジェクトに格納されるので注意です。</p>
<p><code>{parameters{}</code>ブロックでは項目$I$について仮定した各行毎に独立の多項分布のパラメータ$\Theta_{i}$を指定しています。</p>
<p><code>model{}</code>ブロックでは$(6)$式のモデルに加え、$\Theta_i$について以下の事前分布を設定しています。これは、相撲データの性質を踏まえて設定したもので、決まり手には比較的メジャーで頻繁に使われる技もあれば、めったに決まる、もしくは使われることのない技もあるだろう、ということを考慮しました。</p>
<p>$$
\Theta_i \sim dirichlet((p_{.1},\ldots,p_{.J})) \tag{10}
$$</p>
<p><code>generated quantities{}</code>ブロックでは、<code>transformed data{}</code>で得た主成分ベクトル<code>eigenvectors_X</code>などの数値とMCMCサンプルを用いて座標の生成量を求めています。項目$I$のポイントについては2通り計算しており、観測度数の期待値から分割表を作成し求めた各ポイントの座標の生成量（<code>Z_EST</code>）と、観測度数の期待値から乱数を発生させて作成した分割表から求めた座標の生成量（<code>Z_RNG</code>）があります。<br>
項目$J$のポイントの座標<code>Z_star</code>についてはMCMCサンプルを用いず、<code>transformed data{}</code>ブロックで得た数値から計算しているだけなので、<code>generated quantities{}</code>で計算する必要はないです。MCMCサンプルの数だけ同じ計算をさせているので、むしろ非効率。<code>transformed data{}</code>で計算した主成分ベクトルをStanオブジェクトに格納できなかったので、こうなってしまいました。</p>
<pre><code>data{
  int&lt;lower=0&gt; Sum; //全観測数の和
  int&lt;lower=0&gt; N; //分割表の列数（列数&lt;行数とする）
  int&lt;lower=N&gt; M; // 分割表の行数
  int d[M,N]; //分割表
}

transformed data{
  matrix[M,N] d_numeric; //分割表。確率行列を作成するためint型の分割表は使えない
  vector[N] eigenvalues_X; //観測値に対する対応分析の結果（固有値）
  matrix[N,N] eigenvectors_X; //観測値に対する対応分析の結果（固有ベクトル）
  vector[M] p_i; //行ごとの観測値全体に占める割合
  vector[N] p_j; //列ごとの観測値全体に占める割合
  matrix[M,M] P_I;
  matrix[N,N] P_J;
  matrix[N,N] sq_P_J;
  matrix[M,N] P_IJ;
  matrix[M,N] X; //主成分分析の対象となる行列


  for(i in 1:M){
    for(j in 1:N){
      d_numeric[i,j] = d[i,j];
    }
  }

  for(i in 1:M){
    p_i[i] = sum(d_numeric[i,]) / Sum;
  }

  for(j in 1:N){
    p_j[j] = sum(d_numeric[,j])/Sum;
  }

  P_I = diag_matrix(p_i);

  P_J = diag_matrix(p_j);

  sq_P_J = diag_matrix(sqrt(p_j));

  P_IJ = d_numeric / Sum;

  {
    matrix[N,N] Sigma; //Xの分散共分散行列
    X = inverse(P_I) * P_IJ * inverse(sq_P_J);

    {
      matrix[M,N] X_bar;
      for(n in 1:N){
        X_bar[,n] = rep_vector(mean(X[,n]),M);
      }
      Sigma = (X - X_bar)' * P_I * (X - X_bar);
    }

    //行列Xの主成分分析を実行
    eigenvalues_X = eigenvalues_sym(Sigma);
    eigenvectors_X = eigenvectors_sym(Sigma);
  }

}

parameters{
  simplex[N] theta[M];
}

model {
  //モデル部分
  for(i in 1:M){
    d[i,] ~ multinomial(theta[i]);
  }
  //事前分布
  for(i in 1:M){
    theta[i] ~ dirichlet(p_j);
  }
}

generated quantities{
  vector[M] Z_EST[2]; //求めたい座標（期待値）
  vector[M] Z_RNG[2]; //求めたい座標（事後分布からの乱数生成）
  vector[N] Z_star[2]; //列変数の座標(事後分布によらない)

  //Z_starを計算する
  {
    vector[M] Z_ori[2]; //観測値から計算した行変数の座標
    for(i in 1:M){
      Z_ori[1,i] = X[i] * eigenvectors_X[,N];
      Z_ori[2,i] = X[i] * eigenvectors_X[,(N-1)];
    }
    Z_star[1,] = 1/sqrt(eigenvalues_X[N]) * inverse(P_J) * P_IJ' * Z_ori[1,];
    Z_star[2,] = 1/sqrt(eigenvalues_X[(N-1)]) * inverse(P_J) * P_IJ' * Z_ori[2,];
  }

  //期待値の座標を計算
  {
    matrix[M,N] P_IJ_EST;
    int d_RNG[M,N];
    matrix[M,N] d_numeric_RNG;
    matrix[M,N] P_IJ_RNG;
    matrix[N,N] sq_P_J_EST;
    matrix[N,N] sq_P_J_RNG;
    matrix[M,N] X_EST;
    matrix[M,N] X_RNG;

    //以降は1MCMC・行毎に必要な操作
    for(i in 1:M){

      //着目する行によってP_IJは異なる
      for(m in 1:M){
        //P_IJの生成
        if(m==i){
          P_IJ_EST[m,] = (theta[i] * (sum(d[i,])) / Sum)'; //対象の行のみ観測数期待値を用いる
        }else{
          P_IJ_EST[m,] = d_numeric[m,] / Sum;
          }
      }

      //着目する行によってP_Jも異なる
      {
        vector[N] sq_p_j_EST;
        for(n in 1:N){
          sq_p_j_EST[n] = sqrt(sum(P_IJ_EST[,n]));
        }
        sq_P_J_EST = diag_matrix(sq_p_j_EST);
      }

      X_EST = inverse(P_I) * P_IJ_EST * inverse(sq_P_J_EST);

      Z_EST[1,i] = X_EST[i] * eigenvectors_X[,N];
      Z_EST[2,i] = X_EST[i] * eigenvectors_X[,(N-1)];
    }

    //事後分布から乱数生成したときの座標を計算
    for(i in 1:M){

      for(m in 1:M){
        //P_IJの生成
        if(m==i){
          d_RNG[m,] = multinomial_rng(theta[m],sum(d[m,]));
        }else{
          d_RNG[m,] = d[m,];
          }
      }

      for(m in 1:M){
        for(n in 1:N){
          d_numeric_RNG[m,n] = d_RNG[m,n];
        }
      }

      P_IJ_RNG = d_numeric_RNG / Sum;

      {
        vector[N] sq_p_j_RNG;
        for(n in 1:N){
          sq_p_j_RNG[n] = sqrt(sum(P_IJ_RNG[,n]));
        }
        sq_P_J_RNG = diag_matrix(sq_p_j_RNG);
      }

      X_RNG = inverse(P_I) * P_IJ_RNG * inverse(sq_P_J_RNG);

      Z_RNG[1,i] = X_RNG[i] * eigenvectors_X[,N];
      Z_RNG[2,i] = X_RNG[i] * eigenvectors_X[,(N-1)];
    }
  }
}

</code></pre><h1 id="結果の確認">結果の確認</h1>
<p>以下でMCMCを走らせ、$\hat{R}$で収束を確認します。。モデル部分が簡素なのですぐ終わりますし、収束もばっちりですわ。</p>
<pre><code>library(rstan)
N &lt;- sum(smo_data)
m &lt;- nrow(smo_data)
n &lt;- ncol(smo_data)
data &lt;- list(Sum=N, N=n, M=m, d=smo_data)

rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
fit &lt;- stan(file=&quot;model.stan&quot;, data=data, chains = 4, iter=1300, warmup = 300)

print(fit, pars=&quot;theta&quot;)

## mean se_mean   sd 2.5%  25%  50%  75% 97.5% n_eff Rhat
## theta[1,1]  0.47       0 0.08 0.30 0.41 0.47 0.53  0.63  6965    1
## theta[1,2]  0.46       0 0.08 0.30 0.40 0.46 0.52  0.62  6147    1
## theta[1,3]  0.01       0 0.01 0.00 0.00 0.00 0.00  0.04  4527    1
## theta[1,4]  0.00       0 0.01 0.00 0.00 0.00 0.00  0.03  4572    1
## theta[1,5]  0.03       0 0.03 0.00 0.01 0.02 0.04  0.11  3747    1
## theta[1,6]  0.00       0 0.00 0.00 0.00 0.00 0.00  0.00  4123    1
## theta[1,7]  0.03       0 0.03 0.00 0.01 0.02 0.05  0.11  4463    1
## ～（以下略）～
</code></pre><p>次にインスタ映えプロットを作ります。今回のインスタ映えプロットは観測値から得られる（真の）第1軸と第2軸をもとに付置した対応分析の同時付置図です。項目$I$の各ポイントについてはそのベイズ信頼区間を示しました<sup id="fnref:10"><a href="#fn:10" class="footnote-ref" role="doc-noteref">10</a></sup>。</p>
<pre><code>library(tidyr)
library(dplyr)
library(stringr)
library(tibble)
library(ggplot2)
library(ggrepel)

# MAP 推定値を得る関数
MAP &lt;- function(x){
  dens &lt;- density(x)
  mode_i &lt;- which.max(dens$y)
  mode_x &lt;- dens$x[mode_i]
  return(mode_x)
}

fit %&gt;% rstan::extract() %&gt;% data.frame() %&gt;%
  select(starts_with(&quot;Z_EST&quot;)) %&gt;% pivot_longer(everything(), names_to=&quot;key&quot;, values_to = &quot;val&quot;) %&gt;%
  mutate(dim=as.numeric(str_sub(key, start=7,end=7)),
         target=as.numeric(str_sub(key,start=9, end=10)),
         key=NULL) %&gt;% group_by(target, dim) %&gt;% nest() %&gt;%
  pivot_wider(names_from = dim, values_from = data) %&gt;% unnest() %&gt;% group_by(target) %&gt;%
  rename(X=val, Y=val1) %&gt;% summarise_all(funs(MAP=MAP(.),lower=quantile(., 0.25),upper=quantile(.,0.75))) %&gt;% arrange(target) %&gt;%
  mutate(target=factor(1:20,
                       labels=c(&quot;小錦&quot;,&quot;琴錦&quot;,&quot;貴闘力&quot;,&quot;霧島&quot;,&quot;栃ノ和歌&quot;,&quot;水戸錦&quot;,&quot;若ノ花&quot;,&quot;貴ノ花&quot;,&quot;武蔵丸&quot;,
                                &quot;大翔山&quot;,&quot;安芸ノ島&quot;,&quot;三杉里&quot;,&quot;旭道山&quot;,&quot;舞の海&quot;,&quot;寺尾&quot;,&quot;琴の若&quot;,&quot;貴ノ浪&quot;,
                                &quot;琴富士&quot;,&quot;隆三杉&quot;,&quot;春日富士&quot;))) -&gt; plot_row_EST.df

fit %&gt;% rstan::extract() %&gt;% data.frame() %&gt;%
  select(starts_with(&quot;Z_star&quot;)) %&gt;% pivot_longer(everything(), names_to=&quot;key&quot;, values_to = &quot;val&quot;) %&gt;%
  mutate(dim=str_sub(key, start=8,end=8),
         target=str_sub(key,start=10, end=10),
         key=NULL) %&gt;% group_by(target, dim) %&gt;% nest() %&gt;%
  pivot_wider(names_from = dim, values_from = data) %&gt;% unnest() %&gt;% group_by(target) %&gt;%
  rename(X=val, Y=val1) %&gt;% summarise_all(funs(mean=mean(.))) %&gt;%
  mutate(target=factor(1:7,
                       label=c(&quot;寄り&quot;,&quot;押し&quot;,&quot;投げ&quot;,&quot;引き&quot;,&quot;送り&quot;,&quot;突き&quot;,&quot;その他&quot;))) -&gt; plot_Z_star.df

fit %&gt;% rstan::extract() %&gt;% data.frame() %&gt;%
  select(starts_with(&quot;Z_EST&quot;)) %&gt;% pivot_longer(everything(), names_to=&quot;key&quot;, values_to = &quot;val&quot;) %&gt;%
  mutate(dim=as.numeric(str_sub(key, start=7,end=7)),
         target=str_sub(key,start=9, end=10),
         key=NULL) %&gt;% group_by(target, dim) %&gt;% nest() %&gt;%
  pivot_wider(names_from = dim, values_from = data) %&gt;% unnest() %&gt;%
  rename(X=val, Y=val1) %&gt;% ungroup() %&gt;% mutate(target=factor(target,levels=1:20,
                                                                labels=c(&quot;小錦&quot;,&quot;琴錦&quot;,&quot;貴闘力&quot;,&quot;霧島&quot;,&quot;栃ノ和歌&quot;,&quot;水戸錦&quot;,&quot;若ノ花&quot;,&quot;貴ノ花&quot;,&quot;武蔵丸&quot;,
                                                                         &quot;大翔山&quot;,&quot;安芸ノ島&quot;,&quot;三杉里&quot;,&quot;旭道山&quot;,&quot;舞の海&quot;,&quot;寺尾&quot;,&quot;琴の若&quot;,&quot;貴ノ浪&quot;,
                                                                         &quot;琴富士&quot;,&quot;隆三杉&quot;,&quot;春日富士&quot;)))-&gt; plot_row_EST_range.df

# 観測度数の期待値による同時付置図作成（EST_plot）

library(RColorBrewer)
mycol &lt;- c(brewer.pal(11,&quot;Paired&quot;),brewer.pal(9,&quot;Set1&quot;))

p &lt;- ggplot() +
  theme_light(base_size=11) + guides(alpha=FALSE) +
  stat_density_2d(data=plot_row_EST_range.df, aes(x=X, y=Y, alpha=..nlevel.., fill=target), geom=&quot;polygon&quot;, bins=7,) +
  geom_errorbar(data=plot_row_EST.df, aes(x=X_MAP, y=Y_MAP,ymin=Y_lower, ymax=Y_upper),col=&quot;grey30&quot;, width=0.1,alpha=1) +
  geom_errorbarh(data=plot_row_EST.df, aes(y=Y_MAP,xmin=X_lower, xmax=X_upper,),col=&quot;grey30&quot;, height=0.1,alpha=1) +
  geom_point(data=plot_Z_star.df, aes(x=X_mean, y=Y_mean),size=2, shape=17) +
  geom_point(data=plot_row_EST.df, aes(x=X_MAP, y=Y_MAP,fill=target),shape=21,size=2) +
  geom_text_repel(data=plot_row_EST.df,aes(x=X_MAP,y=Y_MAP,label=target)) +
  geom_text_repel(data=plot_Z_star.df, aes(x=X_mean, y=Y_mean, label=target)) +
  labs(title=&quot;Correspondence Analysis with Bayesian 50% confidence intervas &amp; density&quot;, x=&quot;dim1&quot;, y=&quot;dim2&quot;) +
  theme(legend.title = element_blank()) +
  scale_fill_manual(values=mycol) +
  scale_alpha_continuous(range=c(0.1,0.5))
</code></pre><p><img src="/my-page/post/corresp-and-bayes/res_plot_density(EST).png" alt="uni"></p>
<p>なんと美しい図であろうか。美しい図であるほど人間の優れた視認能力を最大限発揮することができるのです。</p>
<p>対応分析の結果の解釈は<a href="https://rmorita-stat.github.io/my-page/post/correspondencenalysis/correspondenceanalysis/#%E7%B5%90%E6%9E%9C%E3%81%AE%E8%A7%A3%E9%87%88">前回の記事</a>に譲り、項目$I$の各ポイントの信頼区間について確認してみます。</p>
<p>黒星の最も多い力士は貴乃花で59、最も少ない力士は春日富士で25でした。そこで両者の付置の信頼区間をみると、春日富士の方がやはり貴乃花よりも推定幅が広いようです。がしかしその差は明瞭ではなく、貴乃花よりも貴闘力（黒星43）のほうが信頼区間の幅が狭いです。主成分ベクトルによる写像の影響も絡んでいるのでしょう。<br>
一応貴ノ花と春日富士の従う多項分布のパラメータの事後分布を確認します。春日富士の方がやはり事後分布の幅が広い？
<img src="/my-page/post/corresp-and-bayes/res_plot_posterior(%E8%B2%B4%E3%83%8E%E8%8A%B1).png" alt="uni">
<img src="/my-page/post/corresp-and-bayes/res_plot_posterior(%E6%98%A5%E6%97%A5%E5%AF%8C%E5%A3%AB).png" alt="uni"></p>
<p>パラメータの事後分布から乱数生成して求めた各ポイントの座標の予測区間も示しておきます<sup id="fnref:11"><a href="#fn:11" class="footnote-ref" role="doc-noteref">11</a></sup>。誤差を考慮したので当然着色部の幅が広くなっています。</p>
<p><img src="/my-page/post/corresp-and-bayes/res_plot_density(RNG).png" alt="uni"></p>
<h1 id="おまけ私が相撲に参加すると">おまけ～私が相撲に参加すると？～</h1>
<p>標本数の違いによる信頼区間の幅の差があまり実感出来なかったので、極端な例で試してみました。<br>
私(R.morta)が相撲に参加した体で、新たな行を作成します。ただ私は相撲などしたことがない一般人なので、当然力士に勝てる見込みもありません。それでは分割表が作れないので、八百長をした体にして、「引き」での勝ち数が多いことにしてみましょう<sup id="fnref:12"><a href="#fn:12" class="footnote-ref" role="doc-noteref">12</a></sup>。</p>
<pre><code>smo_data &lt;- matrix(data=c(15,15,0,0,1,0,1,19,9,7,12,1,3,3,4,22,0,11,2,0,4,
                          14,3,11,3,1,1,6,24,7,5,5,0,0,2,30,2,6,2,2,0,2,
                          11,13,5,6,2,1,4,25,8,10,7,5,3,1,13,31,3,3,0,2,3,
                          8,2,19,3,2,0,4,28,8,8,2,1,0,7,9,3,14,11,2,0,4,
                          5,3,12,11,4,0,7,7,1,18,0,1,0,11,12,6,1,12,7,2,2,
                          25,2,11,3,1,0,1,16,4,18,3,0,0,5,23,2,6,5,1,0,2,
                          7,17,2,16,3,0,1,2,8,1,11,1,0,2,
                          3,0,1,5,0,0,2),byrow=TRUE, ncol=7)
colnames(smo_data) &lt;- c(&quot;寄り&quot;,&quot;押し&quot;,&quot;投げ&quot;,&quot;引き&quot;,&quot;送り&quot;,&quot;突き&quot;,&quot;その他&quot;)
rownames(smo_data) &lt;- c(&quot;小錦&quot;,&quot;琴錦&quot;,&quot;貴闘力&quot;,&quot;霧島&quot;,&quot;栃ノ和歌&quot;,&quot;水戸錦&quot;,&quot;若ノ花&quot;,&quot;貴ノ花&quot;,&quot;武蔵丸&quot;,
                        &quot;大翔山&quot;,&quot;安芸ノ島&quot;,&quot;三杉里&quot;,&quot;旭道山&quot;,&quot;舞の海&quot;,&quot;寺尾&quot;,&quot;琴の若&quot;,&quot;貴ノ浪&quot;,
                        &quot;琴富士&quot;,&quot;隆三杉&quot;,&quot;春日富士&quot;,&quot;R.morita&quot;)
～（以下略）～

</code></pre><p><img src="/my-page/post/corresp-and-bayes/res_plot_posterior(R.morita).png" alt="uni"></p>
<p>私の従う多項分布のパラメータ事後分布幅はやはり広いですね。
インスタ映えプロットも見てみましょう。</p>
<p><img src="/my-page/post/corresp-and-bayes/res_plot_density(EST)_R.morita.png" alt="uni"></p>
<p>期待通りの結果です。「組んで取る相撲」-「離れて取る相撲」私の信頼区間だけ他と比べて広いです。特に「引き」の寄与が大きい「組んで取る相撲」-「離れて取る相撲」の第2軸についてその傾向が大きく、第二軸の座標の正負もあやしい状態です。</p>
<p>以上で対応分析の同時付置図に各ポイントの信頼区間を示すことが出来ていることを確認できました。</p>
<h1 id="まとめ">まとめ</h1>
<p>対応分析の同時付置図にベイズ信頼区間を表示する試みを紹介しました。<br>
同時付置図を基に項目をパターン分けしたりする際、今回のような方法で同時付置図上にポイントの信頼区間を表示することで、誤った判断を下すことを防げるのではないかと思っています。<br>
あとは図がとても美しい…</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>$N$個の列変量に対する次元削減を狙いとした主成分分析なので、$N$個の固有値・固有ベクトルが得られます。そのうち最小固有値は自明な解$\lambda_{N}≃0$、$l_{N}=(\sqrt{p_{.1}},\ldots,\sqrt{p_{.N}})$であり、それを除いた$N-1$次元が得られる次元になるようです。（論文では自明な解$\lambda_{N}≃1$と記載されていたが計算すると自明な固有ベクトルに対応する固有値は0に近かった。なぜ？） <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>行列$X$のユークリッド距離が$\cfrac{f_{ij}}{f_{i.}}$に関する行項目間の$χ^2$距離になっているので、分割表の一様性の検定における検定対象は対応分析において視覚的に強調しようとしている対象そのものになっています <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>参考論文では帰無仮説：$\cfrac{p_{ij}}{p_{i.}} = p_{.j}$となっていますが同じことです。分かりにくいナ <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>4で割ると整数にならない観測度数がでてきますが気にしないようにしましょう。整数じゃなくても検定はできます。 <a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p>自明な固有ベクトルとの内積になっているので0です <a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6" role="doc-endnote">
<p>最右辺の$\cfrac{\left(\cfrac{p_{ij}}{p_{i.}}-p_{.j}\right)^2}{p_{.j}}$は、対応分析で視覚的に強調しようとしている対象そのものです <a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:7" role="doc-endnote">
<p>信頼区間とは？予測区間とは？ <a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:8" role="doc-endnote">
<p>行・列に対して別々に独立の生成過程を仮定した場合の結果が同時付置図ですが… <a href="#fnref:8" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:9" role="doc-endnote">
<p>$p_{ij}$に$Multinom(f_{i.}, \Theta_{i})$からの乱数をあてはめる場合は、この行列の$i$行目にも同じ乱数生成量を使います <a href="#fnref:9" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:10" role="doc-endnote">
<p>エラーバーで各座標の50%信頼区間を、着色で二次元カーネル密度推定結果の等高線の最大値を1としたときの、0.2以上の範囲を描画しています。着色部は80%ベイズ信頼区間に相当する？ <a href="#fnref:10" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:11" role="doc-endnote">
<p>Z_RNGをZ_ESTのかわりに用いることで得られます。 <a href="#fnref:11" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:12" role="doc-endnote">
<p>八百長での決まり手には「引き」がよく採用されるようです <a href="#fnref:12" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

        </article>
    </div>
    <div class="main-content__tags u-font">
        
        
        <span><a href="https://rmorita-stat.github.io/my-page/tags/%E5%A4%9A%E5%A4%89%E9%87%8F%E8%A7%A3%E6%9E%90">多変量解析</a></span>
        
        <span><a href="https://rmorita-stat.github.io/my-page/tags/rstan">rstan</a></span>
        
        
    </div>
</div>
<div class="main-profile">
    <div class="main-profile__avatar">
        
    </div>
    <div class="main-profile__body">
        <div class="main-profile__author">
            
            <span> R.morita </span>
            
        </div>
        <div class="main-profile__description">
            
            <p> 洛中で6年間大学生活を過ごし、今は難波の地で働いています。統計、ロードバイク、古墳が好きです。 </p>
            
        </div>
    </div>
</div>
<div class="main-line"></div>
<div class="main-pn">
    
    
    <a class="next" href="https://rmorita-stat.github.io/my-page/post/multinom/multinom/">
        <div class="pn-dec"></div>
        <div class="pn-els">
            <div class="pn-el__1"> 2020.05.27 21:13 </div>
            <div class="pn-el__2"> multinom()を使った多項ロジスティック回帰 </div>
        </div>
    </a>
    
</div>

<footer>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  "HTML-CSS": {
    availableFonts: ["TeX"]
  }
  });
</script>
</footer>

</div>
<div class="footer">
    <div class="copyright-wrap">
        <p class="copyright u-font">
            
            &#169;
            2020
            
            <a href="https://github.com/Rmorita-stat/doc" target="_blank">R.morita&#46;</a>
            Theme <a href="https://github.com/iCyris/hugo-theme-yuki" target="_blank">yuki</a>&#46;
            Powered by Hugo&#46;
            
            
        </p>
    </div>
</div>
</body>
<script src="https://rmorita-stat.github.io/my-page/js/page.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

